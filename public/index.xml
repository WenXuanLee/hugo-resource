<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ben the front-end dust on Ben the front-end dust</title>
    <link>https://WenXuanLee.github.io/</link>
    <description>Recent content in Ben the front-end dust on Ben the front-end dust</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Wed, 09 Jan 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Socket Programming</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/tcpandudp/</link>
      <pubDate>Wed, 09 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/tcpandudp/</guid>
      <description>

&lt;h2 id=&#34;socket-programming-creating-network-applications&#34;&gt;Socket Programming: Creating Network Applications&lt;/h2&gt;

&lt;p&gt;複習一下當我們建立一個network application，我們基本上包含了一組programs，client program &amp;amp; server program，分別存在於兩個end system，當兩個program執行後，client process &amp;amp; server process被建立，這些processes透過socket互相溝通，因此身為一個developer主要就是負責撰寫code for clicent program &amp;amp; server program&lt;/p&gt;

&lt;p&gt;Network applications有兩種types，一種為&lt;code&gt;implementation&lt;/code&gt;，主要&lt;code&gt;實作於protocol standard&lt;/code&gt;，例如 RFC 或者其他 standard document，這樣的application通常又被稱為&lt;code&gt;open&lt;/code&gt;，因為規則以及行為是被公開，因此此類別的程式設計需要&lt;code&gt;遵守standard的標準&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;另一種type則為&lt;code&gt;proprietary&lt;/code&gt;，此類型主要&lt;code&gt;運用的protocol&lt;/code&gt;尚未被公開發布在RFC或者其他國際網路規範，client side &amp;amp; server side program都由同組開發者完成，而開發者完全掌控code的內容，由於此類別並非實作於公開的protocol上，其他獨立開發者也就不能開發與此application相互操作的code。&lt;/p&gt;

&lt;p&gt;下面會透過簡單實作的code來探討開發一個client-server application的簡易流程，在開發者階段，第一步主要得&lt;code&gt;決定此application是基於 TCP || UDP&lt;/code&gt;，因此會就此兩種protocol類型來介紹。&lt;/p&gt;

&lt;h3 id=&#34;socket-programming-with-udp&#34;&gt;Socket Programming with UDP&lt;/h3&gt;

&lt;p&gt;sending process將packet push 到 socket 前，UDP會先將&lt;code&gt;destination address&lt;/code&gt;資訊帶給packet，packet到達sending socket時，Internet便會根據此資訊導引到receiving process socket。由於傳遞的途中或許會經過許多network application process以及多個sockets，辨別destination receiver socket是必要的，因此在socket建立過程中，&lt;code&gt;port number&lt;/code&gt;會被指認到socket當作idtentifier。而此項訊息也會被包含在destination address裡。此外，source address的資訊有同樣會被帶入packet，特別注意到，source address的帶入動作並非由UDP application code執行，而是自動由operating system完成的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190109/20107670LFn1xTVweA.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190109/20107670LFn1xTVweA.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;socket-programming-with-tcp&#34;&gt;Socket Programming with TCP&lt;/h3&gt;

&lt;p&gt;不同於UDP，在client &amp;amp; server 開始彼此溝通前，必須先通過&lt;code&gt;handshake&lt;/code&gt;的行為並建立&lt;code&gt;TCP conntection&lt;/code&gt;，&lt;code&gt;TCP connection&lt;/code&gt;的兩端分別連結著sending socket &amp;amp; receiver socket，建立的同時也會將兩端的IP address 以及 port number連結於TCP connection上，兩端的互動都將由&lt;code&gt;socket把data丟到TCP connection&lt;/code&gt;傳遞。不同於UDP的server必須先將destination address 附在 packet上才能進入socket傳遞。&lt;/p&gt;

&lt;p&gt;相同的是，兩者的server都必須是在running的狀態下，client端才能initiate動作。而在TCP中，首先 clicent initiate a TCP connection to the server，這在&lt;code&gt;client program建立TCP socket&lt;/code&gt;時完成，當建立的途中會將&lt;code&gt;Server host&lt;/code&gt;的&lt;code&gt;IP address&lt;/code&gt;以及 socket的&lt;code&gt;port number&lt;/code&gt;帶入，建立完成後開始three-way handshake並建立TCP connection with the server，建立connection主要是在&lt;code&gt;transport layer&lt;/code&gt;，在應用層的client and server program是觀察不到的。
  &lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190109/20107670kCTXHqFZcm.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190109/20107670kCTXHqFZcm.png&#34; /&gt;
  TCP socket為所有建立tcp coneection之前先執行一個打招呼的動作，也就是handshake的部分，接著的connection socket才是主要用於傳遞溝通的管道，
  &lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190109/20107670lCOBfgQJMM.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190109/20107670lCOBfgQJMM.png&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Peer-to-Peer Applications</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/p2p/</link>
      <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/p2p/</guid>
      <description>

&lt;h2 id=&#34;peer-to-peer-applications&#34;&gt;Peer-to-Peer Applications&lt;/h2&gt;

&lt;p&gt;探討適合用於P2P設計的application，主要分於兩部分，第一部分為&lt;code&gt;file distribution&lt;/code&gt;，介紹檔案如何從單一來源分配至多數的peers，這部分清楚的展示了&lt;code&gt;P2P架構的 self-scalability&lt;/code&gt;，主要透過BitTorrent system為範例。第二部分則會探討 &lt;code&gt;database distributed over a large community of peers&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;p2p-file-distribution&#34;&gt;P2P File Distribution&lt;/h3&gt;

&lt;p&gt;每個peer都可以提供自己的capacity來幫助server distribute 檔案，不同於client-server的模式，在分配檔案時，server不需要copy每一份檔案給peers，反之，只要其中一個peer擁有檔案之後便可以透過此peer重新再分配檔案到其他peers。放一張比較圖&lt;/p&gt;

&lt;h3 id=&#34;bittorrent&#34;&gt;BitTorrent&lt;/h3&gt;

&lt;p&gt;Torrent在此的定義為，所有參與同一檔案distribution的peers的集合，每個於此Torrent的peer都會下載同樣容量的&lt;code&gt;chunks&lt;/code&gt;，通常為256KBytes為一個chunk，當peer首次加入torrent並無任何chunk，隨著時間他會存入越來越多chunk，下載的同時也成為upload的來源之一，但檔案完成後可以選擇繼續留著torrent當為upload source之一繼續提供流量或者就離開torrent。&lt;/p&gt;

&lt;p&gt;每一個torrent會擁有基本的node called tracker，當peer加入torrent時，會把自己註冊進tracker裡面並固定一小段時間通知tracker我還在torrent裡面。當一個新的peer加入時，tracker會隨機挑出一個peers子集合以及這群子集合的IP address丟給新的peer，擁有這些資訊後，新的peer便能與這群子集合建立TCP connection，通常這樣的子集合群稱為&lt;code&gt;neighboring peers&lt;/code&gt;，建立TCP連結後便能從這群peers裡面獲取需要的chunks。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;rarest first&lt;/strong&gt; 決定取得chunck採用的技術之一，會從使用者當前沒有的chunks裡面去判斷，這些尚未擁有的chunck哪些是在&lt;code&gt;neiboring peers&lt;/code&gt;重複性最低的，優先抓取此chunk。目標在於讓此rarest chunk更快的能在torrent裡面擁有與其他chunks一樣多的copies。&lt;/p&gt;

&lt;p&gt;在BitTorrent協定中，主要根據peers內擁有最高的傳輸速率作為respond的判斷依據，也就是說，每十秒使用者會偵測接受到的rate以及upload rate，這個符合最高速率的set稱為&lt;code&gt;unchoked&lt;/code&gt;，而每三十秒會隨機抓取一個額外的&lt;code&gt;neighboring peer&lt;/code&gt;傳送chunck，此額外的peer稱為&lt;code&gt;optimistically unchoked&lt;/code&gt;，若此peer正好速率高過於unchoked的其中一個，則此會替代成為&lt;code&gt;unchoked&lt;/code&gt;之一，相對來說，若互相都滿足彼此的highest rate，則互為&lt;code&gt;unchoked&lt;/code&gt;之一。&lt;/p&gt;

&lt;p&gt;其他&lt;code&gt;neighboring peer&lt;/code&gt;則稱為&lt;code&gt;choked&lt;/code&gt;也就是不再&lt;code&gt;top four peers(unchoked) and one probing peer(optimistically unchoked&lt;/code&gt;裡面，&lt;code&gt;choked&lt;/code&gt;並不會接受從使用者接收到chunks。&lt;/p&gt;

&lt;h3 id=&#34;distributed-hash-tables-dhts&#34;&gt;Distributed Hash Tables(DHTs)&lt;/h3&gt;

&lt;p&gt;P2P系統裡，每一個peer會存取一小部分的key-value pairs，每一個peer都可以發出query到distributed database獲取對應的value，收到query後database作抓取擁有此key值value的peer並回傳給發出query之peer，任何一個peer都准許插入新的 key-value paris到database裡面，這樣的設計稱為 &lt;code&gt;distributed hash table&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>The Internet&#39;s Directory Service</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/dns/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/dns/</guid>
      <description>

&lt;h2 id=&#34;dns-the-internet-s-directory-service&#34;&gt;DNS The Internet&amp;rsquo;s Directory Service&lt;/h2&gt;

&lt;p&gt;網路上主要辨識host的方法為&lt;code&gt;hostname &amp;amp; IP address&lt;/code&gt;，&lt;code&gt;IP&lt;/code&gt;主要由&lt;code&gt;4 bytes&lt;/code&gt;以及有自己的嚴格規則形式組成，使用者習慣使用網址來記host，而&lt;code&gt;router&lt;/code&gt;則是偏好固定規則的&lt;code&gt;IP address&lt;/code&gt;，為了整合這兩種特性，於是有了&lt;code&gt;DNS (domain name system)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;DNS是&lt;code&gt;IP address &amp;amp; hostname&lt;/code&gt;對映的分散式資料庫，應用層的協定允許&lt;code&gt;hosts&lt;/code&gt;對此資料庫發送&lt;code&gt;query&lt;/code&gt;，DNS協定主要以UDP為底使用port 53。之前提過的&lt;code&gt;HTTP SMTP FTP&lt;/code&gt;也都有使用此協定，用於將此用者提供的hostname轉化成對應的IP。&lt;/p&gt;

&lt;p&gt;所以當我們輸入網址，發送request時，會先觸發DNS application，browser從URL抓取host name並傳給DNS application，接著DNS clicent 傳送包含此hostname的query給DNS server，獲得對映的IP address，再回傳給browser，一旦browser獲取到IP後便開始建立TCP通道。而注意到通常IP網址會被快取在 &lt;code&gt;nearby&lt;/code&gt;的&lt;code&gt;DNS server內&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;overview-of-how-dns-works&#34;&gt;Overview of How DNS Works&lt;/h3&gt;

&lt;p&gt;DNS是如何從DNS Server 找到對應的IP ADDRESS呢，如上述我們提到的DNS server，實際上的架構是有階級制的架構，由上而下為&lt;code&gt;Root server -&amp;gt; TLD(top-level domain) server -&amp;gt; authoritative DNS servers&lt;/code&gt;，假使今天看到amazon.com的網址，DNS會從root開始聯繫，root 回傳對應到的 IP address以及TLD server，接著再從TLD server回傳對應到的IP address及 authoritative DNS server，最後回傳準確的IP address。&lt;/p&gt;

&lt;p&gt;值得注意的是，DNS帶有Cacheing的Feature，也就是每當 DNS Server 收到reply message時，是可以cache message裡面的資訊在local memory裡面，當下次再有類似的host name query時，便能從cache住的資訊回傳，即便此DNS server 不是 authoritative for the hostname的，由於 IP address &amp;amp; hostname的關係並不是永久的，通常cache的資訊兩天後就會被拋棄。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181226/20107670cUJZ136hpX.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181226/20107670cUJZ136hpX.png&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Root DNS&lt;/strong&gt; - 根據2011 秋天的資料 目前全球大概有 247 root servers。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TLD&lt;/strong&gt; - 高等DNS domain如常見的 .org .net .edu .gov等等都是，以及所有帶有國家代號的如.tw .US等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Authoritative DNS server&lt;/strong&gt; - 最接近我們的DNS server，通常一個企業可以自己組一台DNS server保存紀錄，或者付錢給特定企業儲存，通常公司都會擁有自己的主要以及輩分的DNS server&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DNS server擁有一個重要的type &lt;code&gt;local DNS server&lt;/code&gt;，並不屬於上面的階級結構，但在DNS架構中也是一個重要的角色，每個&lt;code&gt;ISP&lt;/code&gt;會擁有自己的&lt;code&gt;local DNS server (default name server)&lt;/code&gt;，當我們連結到ISP時，便是透過local DNS server取得對映的位址，當我們發出一個DNS query首先就會經過local DNS server，再由local DNS server以proxy的形式傳送query到階級制的DNS server裡去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181227/20107670D5pZVe5IDk.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181227/20107670D5pZVe5IDk.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;dns-records-and-messages&#34;&gt;DNS Records and Messages&lt;/h3&gt;

&lt;p&gt;Message組成主要有四種fields&lt;code&gt;(Name, Value, Type, TTL)&lt;/code&gt;，TTL決定了resource record何時從cache清除，type包含了幾種狀態，Name &amp;amp; Value主要相異於Type的回傳&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Type A - DNS 已經找到對應的 hostname-IP address，Name為hostname、Value為IP address (relay1.bar.foo.com, 145.37.93.126, A)&lt;/li&gt;
&lt;li&gt;Type NS - DNS server 知道此record存於哪個authoritative server Name為domain name、Value為authoritative server(foo.com, dns.foo.com, NS)&lt;/li&gt;
&lt;li&gt;Type CNAME - Value為類名稱，Name為domain name (foo.com, relay1.bar.foo.com, CNAME)&lt;/li&gt;
&lt;li&gt;Type MX - Value是mail server的類名稱(foo.com, mail.bar.foo.com, MX)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;DNS query &amp;amp; replay message擁有同樣的形式，&lt;code&gt;前12個bytes為header section&lt;/code&gt;，主要包含幾個區塊，第一個區塊為&lt;code&gt;16-bit的數字&lt;/code&gt;，讓client可以去&lt;code&gt;match reply &amp;amp; query&lt;/code&gt;，再來包含幾個&lt;code&gt;flag field&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1-bit query/reply flag - 辨認message為query(0) or reply(1)&lt;/li&gt;
&lt;li&gt;1-bit authoritative flags - 當找到DNS server for queried name，設於replay message裡&lt;/li&gt;
&lt;li&gt;1-bit recursiondesired flag - 當client找不到record時重複執行動作&lt;/li&gt;
&lt;li&gt;1-bit available field - 當DNS server 支援 recursion&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第二部分為&lt;code&gt;Question section&lt;/code&gt;，帶有query information，包含&lt;code&gt;name field、type field&lt;/code&gt;，再來為reply message的&lt;code&gt;Answer section&lt;/code&gt;，包含了queried name，以及每筆record type、Value、TTL。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181228/20107670iKjo6BYgZs.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181228/20107670iKjo6BYgZs.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;inserting-records-into-the-dns-database&#34;&gt;Inserting Records into the DNS Database&lt;/h3&gt;

&lt;p&gt;假使今天我想架設一個個人網站為BenTheDust.com，首先我肯定得先&lt;code&gt;註冊我的domain name&lt;/code&gt;，&lt;code&gt;registrar&lt;/code&gt;指的是間實體公司負責驗證此&lt;code&gt;domain name的唯一性&lt;/code&gt;並將此&lt;code&gt;domain name加入DNS database&lt;/code&gt;，並提供此服務的些許費用。當註冊完domain name後，接下來得提供&lt;code&gt;registrar&lt;/code&gt;對應的pair name &amp;amp; IP address以及主要認可和次要的authoritative DNS servers。有了這些資訊，registrar便可以確保 &lt;code&gt;Type NS &amp;amp; Type A&lt;/code&gt;的紀錄是有存進&lt;code&gt;TLD com servers&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;DNS在發展中，在協定裏加入了&lt;code&gt;UPDATE OPTION&lt;/code&gt;讓data可以從database透過DNS message動態的增加或刪除，當這些紀錄record的步驟完成後，便可以連到我們的個人網站。&lt;/p&gt;

&lt;p&gt;再複習一下DNS的流程步驟，假使今天Ben要連到BenTheDust.com，流程便會如下圖
&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190107/20107670dxmrnbmqxB.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190107/20107670dxmrnbmqxB.png&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Overview FTP &amp; SMTP</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/mailandfile/</link>
      <pubDate>Tue, 25 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/mailandfile/</guid>
      <description>

&lt;h2 id=&#34;file-transfer-ftp&#34;&gt;File Transfer FTP&lt;/h2&gt;

&lt;p&gt;user 主要透過 &lt;code&gt;FTP user agent&lt;/code&gt;與&lt;code&gt;FTP&lt;/code&gt;互動，為了辨認User，User會提供&lt;code&gt;User identification and password&lt;/code&gt;給FTP辨認用，&lt;code&gt;FTP&lt;/code&gt;同HTTP是以&lt;code&gt;TCP protocol&lt;/code&gt;為基本運作，但不一樣的是，&lt;code&gt;FTP&lt;/code&gt;使用了&lt;code&gt;Two parallel TCP connections&lt;/code&gt;來傳遞檔案，&lt;code&gt;control connection &amp;amp; data connection&lt;/code&gt;，前者主要用來傳遞&lt;code&gt;hosts 的 control information &amp;amp; commands to put and get files&lt;/code&gt;，後者則為實際真的&lt;code&gt;傳送檔案&lt;/code&gt;，特別注意到&lt;code&gt;data connection&lt;/code&gt;是&lt;code&gt;non-persisent&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FTP server&lt;/code&gt;是必須維持user state的，也就是&lt;code&gt;server&lt;/code&gt;會觀察user在要求檔案或者抓取檔案時的行為，FTP同樣會回傳Response，帶有基本訊息包含成功或者失敗訊息等等&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670uh2FgUtOJn.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670uh2FgUtOJn.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;electronic-mail-in-the-internet&#34;&gt;Electronic Mail in the Internet&lt;/h2&gt;

&lt;p&gt;三個最主要的核心為，&lt;code&gt;user agents、mail servers、SMTP&lt;/code&gt;，一封電郵的旅途會是這樣的，假使今天A寄了一封信到B，A透過&lt;code&gt;user agent&lt;/code&gt;，也就是g-mail、apple mail&amp;hellip;，讓使用者可以傳送回復編輯信件等等，完成後&lt;code&gt;user agent&lt;/code&gt;會將信件送到&lt;code&gt;user mail servers&lt;/code&gt;，接著從&lt;code&gt;user mail server&lt;/code&gt;傳送到&lt;code&gt;receiver mail server&lt;/code&gt;，接著B的&lt;code&gt;user agent&lt;/code&gt;再從&lt;code&gt;receiver mail server&lt;/code&gt;去抓取信件到B信箱裡面。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mail server&lt;/code&gt;提供了信件的基礎功能，包括若A的信件&lt;strong&gt;無法成功傳遞&lt;/strong&gt;到B的&lt;code&gt;mail server&lt;/code&gt;，則此封信件會排到&lt;code&gt;message queue&lt;/code&gt;裡面，待三十分鐘(常見的頻率)後重試，若多天重試後仍無法成功則移除此&lt;code&gt;message&lt;/code&gt;並由&lt;code&gt;mail server&lt;/code&gt;發送通知給&lt;code&gt;sender&lt;/code&gt;，mail server同時也記錄了&lt;code&gt;憑證確認Sender &amp;amp; receiver&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SMTP protocol&lt;/code&gt;主要為email的協定，套用了&lt;code&gt;reliable data transfer service of TCP&lt;/code&gt;保證信件的傳遞，&lt;code&gt;SMTP&lt;/code&gt;也擁有&lt;code&gt;client &amp;amp; server side&lt;/code&gt;，前者主要作用於&lt;code&gt;sender mail server&lt;/code&gt;，後者則為&lt;code&gt;receive mail sender&lt;/code&gt;，廣義的定義而言，mail server &lt;code&gt;傳送信件&lt;/code&gt;到其他 mail server 視為 &lt;code&gt;client side&lt;/code&gt;，負責&lt;code&gt;接收&lt;/code&gt;的 mail server 則為 &lt;code&gt;server side&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;smtp&#34;&gt;SMTP&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;SMTP&lt;/code&gt;協定主要作用於傳送 message from &lt;code&gt;sender mail server to receiver mail server&lt;/code&gt;，由於電郵是相當有歷史的，所以會有一些歷史上的限制，好比當初設計時，&lt;code&gt;SMTP&lt;/code&gt;限定了所有&lt;code&gt;message body&lt;/code&gt;為&lt;code&gt;7-bit ASCII&lt;/code&gt;，在以前的年代或許7-bit是足夠的，但對於今天而已這樣的設計是種折磨，以致於現今得再進入&lt;code&gt;SMTP&lt;/code&gt;時做出轉碼以及解碼的過程。&lt;/p&gt;

&lt;p&gt;值得注意的一點為，&lt;code&gt;SMTP並不透過中繼server去傳達mail&lt;/code&gt;，也就是若今日sender在香港，receiver在澳洲，那麼兩台的連線也是直接從香港到澳洲的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670IyADlnZAB6.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670IyADlnZAB6.png&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;smtp-http&#34;&gt;SMTP &amp;amp; HTTP&lt;/h3&gt;

&lt;p&gt;簡單比較一下&lt;code&gt;SMTP&lt;/code&gt;以及&lt;code&gt;HTTP&lt;/code&gt;協定的相似處以及相異處，如上線介紹的兩者同樣都是以&lt;code&gt;TCP&lt;/code&gt;為底做為傳輸協定，同樣保證了資料的準確傳遞，而同時也都是&lt;code&gt;persistent connections&lt;/code&gt;，也就是&lt;code&gt;tcp connection&lt;/code&gt;維持暢通，message都可以透過同一條通道傳遞。&lt;/p&gt;

&lt;p&gt;相異處在於&lt;code&gt;HTTP is mainly a pull protocol&lt;/code&gt;，也就是&lt;code&gt;TCP connection&lt;/code&gt;主要是因為&lt;code&gt;sender side想要獲取檔案&lt;/code&gt;或資料而&lt;code&gt;主動initiate&lt;/code&gt;，&lt;code&gt;SMTP 則是 push protocol&lt;/code&gt;，主要觸發點為想要&lt;code&gt;發送資訊到receiver side&lt;/code&gt;。
再來是&lt;code&gt;SMTP&lt;/code&gt;對於message的限制為&lt;code&gt;7-bit ASCII&lt;/code&gt;，&lt;code&gt;HTTP&lt;/code&gt;並沒有此限制。&lt;/p&gt;

&lt;p&gt;再來是message encapsulate的差異，&lt;code&gt;Http&lt;/code&gt;是將個別的request file封裝於個別的response message，而email則是將所有message object 放在同一個response message裡面，也就是說，假使今天同樣要求含有文字與圖片的request，&lt;code&gt;HTTP&lt;/code&gt;會將文字以及圖片分為兩個resonse message回傳，email則是包在同一個message回傳。&lt;/p&gt;

&lt;h3 id=&#34;mail-access-protocols&#34;&gt;Mail Access Protocols&lt;/h3&gt;

&lt;p&gt;如上述所說的，email的傳遞是直接透過雙方的agen以及mail server做傳導，也代表著，若其中一方的host關機的話，另一方的信件不就會一直嘗試連接失敗，然後被放棄，為了因應這種狀況的不便之處，於是有了&lt;code&gt;Access Protocols&lt;/code&gt;的產生，讓B方可以在想要的時候再從&lt;code&gt;B mail server&lt;/code&gt;去接收信件。常見的有以下&lt;code&gt;Post Office
Protocol—Version 3 (POP3), Internet Mail Access Protocol (IMAP), and HTTP&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;pop3&#34;&gt;POP3&lt;/h4&gt;

&lt;p&gt;相對簡易的access protocol，可使用的functionality相對少了點，主要進入點為當&lt;code&gt;client 連接 tcp connection 到 mail server&lt;/code&gt;建立時，&lt;code&gt;POP3&lt;/code&gt;主要有三個階段&lt;code&gt;Authorization、transaction、update&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Authorization - user agent會送出一組使用者名稱以及密碼用以認證user
Transaction - user agent 接收到messages，並在此階段，user agent擁有可以對message做上 &lt;code&gt;deletion mark or remove deletion mark and obtain mail statistics&lt;/code&gt;，也可以&lt;code&gt;issued command&lt;/code&gt;
update - 當client端發起 &lt;code&gt;QUIT command&lt;/code&gt;，結束&lt;code&gt;POP3 session&lt;/code&gt;，此時mail server 會刪除擁有 deletion mark的訊息&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670tW3PICkRWh.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670tW3PICkRWh.png&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;http&#34;&gt;HTTP&lt;/h4&gt;

&lt;p&gt;當今主流都是透過瀏覽器傳遞郵件如google、yahoo，在此舉例中，&lt;code&gt;user agent便是web browser&lt;/code&gt;，瀏覽器透過&lt;code&gt;HTTP&lt;/code&gt;與&lt;code&gt;遠端的mailbox server連結&lt;/code&gt;，所以程序上會變成 A -&amp;gt; browser -&amp;gt; mail server -&amp;gt; B mail server -&amp;gt; B browser -&amp;gt; B，而在mail server傳遞之間注意到， message的傳送與接收仍然是透過&lt;code&gt;SMTP&lt;/code&gt;協定提供服務&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Web Caching</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/webcaching/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/webcaching/</guid>
      <description>

&lt;h2 id=&#34;web-caching&#34;&gt;Web Caching&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Web Cache&lt;/code&gt;，aka &lt;code&gt;proxy server&lt;/code&gt;，&lt;code&gt;network&lt;/code&gt;用於代替&lt;code&gt;Origin Web server&lt;/code&gt;滿足&lt;code&gt;HTTP request&lt;/code&gt;的機制，web cache擁有自己的storage空間，並會把最近收到請求的objects存在storage，user browser可以透過config讓所有的request都先被轉到web cache裡。&lt;/p&gt;

&lt;p&gt;假使今天client端發送出一個request，一樣會建立一條TCP connection至web cache，接著web cache檢查是否有一份備分的object在儲存空間裡，若有的話，web cache直接代替server送回response，若無的話則送出request建立TCP connection至 origin server，取得response後在自己的storage 備份object，接著再送回clicent side。&lt;/p&gt;

&lt;p&gt;web cache 同時是&lt;code&gt;client &amp;amp; server&lt;/code&gt;，web cache主要應用有兩個原因，一者為&lt;code&gt;減少response time for client request&lt;/code&gt;尤其當client to server 的頻寬小於 client to web cache時候，二者為&lt;code&gt;減少traffic&lt;/code&gt;，若request並無真的發至origin server 可以減輕server的負擔並減少access to internet的traffic，因此可以對此設計提升效能。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670wt8j4hoVRv.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20190110/20107670wt8j4hoVRv.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-conditional-get&#34;&gt;The Conditional GET&lt;/h2&gt;

&lt;p&gt;上述提到Web cache的好處，但也有一個隱憂是，假使 origin server的檔案在web cache儲存後有所更動的話，該怎麼處理，HTTP提供一個機制讓web cache可以去確認 object是否為up to date，這機制稱為&lt;code&gt;Condition GET&lt;/code&gt;，符合&lt;code&gt;conditional GET&lt;/code&gt;的條件為&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;request message 用的method 為GET&lt;/li&gt;
&lt;li&gt;request message header line 夾帶 &lt;code&gt;IF-modified-since&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;記得在&lt;code&gt;response message&lt;/code&gt;有著一筆&lt;code&gt;Last-Modified&lt;/code&gt;的紀錄，而當web cache再次收到request時，web cache會觸發&lt;code&gt;up-to-date check&lt;/code&gt; 發出一筆&lt;code&gt;condition GET&lt;/code&gt;夾帶&lt;code&gt;If-modified-since&lt;/code&gt;，若web server判斷無modified的話，則會回傳&lt;code&gt;response without requested object&lt;/code&gt;，並在status line帶著&lt;code&gt;status code 304 not modified&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Overview HTTP</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/httpoverview/</link>
      <pubDate>Tue, 04 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/httpoverview/</guid>
      <description>

&lt;h2 id=&#34;overview-of-http&#34;&gt;Overview of HTTP&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;HyperText Transfer Protocol(HTTP)&lt;/code&gt;，application-layer protocol，被定義在&lt;code&gt;RFC&lt;/code&gt;中，在&lt;code&gt;client program &amp;amp; ser ver program&lt;/code&gt;中被實行，在不同的end systems中執行，在兩端透過交換&lt;code&gt;HTTP messages&lt;/code&gt;進行交流。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Web page(documents)&lt;/code&gt;由不同物件組成，這裡的物件指的是&lt;code&gt;FILE&lt;/code&gt;，例如HTML、JPEG、JS檔案等，而這個PAGE可以透過&lt;code&gt;URL&lt;/code&gt;找到存在位址。&lt;code&gt;URL&lt;/code&gt;則由&lt;code&gt;hostname、object&#39;s pathname&lt;/code&gt;組成。以&lt;a href=&#34;http://www.someSchool.edu/someDepartment/picture.gif&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.someSchool.edu/someDepartment/picture.gif&lt;/a&gt; 舉例，&lt;code&gt;/www.someSchool.edu&lt;/code&gt;就是
hostname，&lt;code&gt;someDepartment/picture.gif&lt;/code&gt;則是檔案的&lt;code&gt;pathname&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;HTTP定義了 web client &amp;amp; web server中間的溝通，包括client如何送出message以及server如何轉送webpage給client，此外，&lt;code&gt;HTTP&lt;/code&gt;使用&lt;code&gt;TCP&lt;/code&gt;作為underlying transport protocol，因此當client端送出一個HTTP request message時會透過socket傳送給tcp connection，也從trp connection經過socket接回到response message，同理於server端亦是，而一旦&lt;code&gt;message&lt;/code&gt;到&lt;code&gt;socket interface&lt;/code&gt;後，訊息的傳遞的掌控就不再client端的手裡而是在&lt;code&gt;tcp protocol&lt;/code&gt;下了。&lt;/p&gt;

&lt;p&gt;值得注意的是&lt;code&gt;HTTP&lt;/code&gt;是被稱為&lt;code&gt;stateless protocol&lt;/code&gt;也就是每次的交流並不會留下痕跡，也因此，就算client端短時間發送一樣的request，對於server端來說，並不會因為剛response完前一筆request就不處理同樣的下一筆，反之仍視為另一筆request回應，儘管內容完全相同。&lt;/p&gt;

&lt;h2 id=&#34;non-persistent-and-persistent-connections&#34;&gt;Non-Persistent and Persistent Connections&lt;/h2&gt;

&lt;p&gt;開發者可以決定當送出request/response pair時，是透過&lt;code&gt;separet TCP connections&lt;/code&gt; 或者是 &lt;code&gt;同一個TCP connection&lt;/code&gt;實行，若為前者則稱為&lt;code&gt;Non-Persistent&lt;/code&gt;後者則為&lt;code&gt;Persistent&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;non-persistent&#34;&gt;Non-Persistent&lt;/h3&gt;

&lt;p&gt;假使今天有一個html file裡面有十張圖片，整個重request到呈現頁面的步驟如下，
1. HTTP clicent processs 啟動一條TCP connection到Server端，建立TCP connection
2. client 透過 socket開始傳送message到server端
3. server端透過socket接收到request message，並在透過socket回傳封裝好的response message
4. HTTP server process 告訴TCP connection 關閉此連結(但實際上並還沒關閉，直到確認clicent端已經接收到正確response後才停止)
5. client端接受到response，TCP connection關閉，開始檢驗回傳的HTML檔案並找到圖片的references
6. 取得十張照片，重複1 ~ 4的步驟十次&lt;/p&gt;

&lt;p&gt;在這個過程中，取得web page的階段，建立了11條TCP connection，每條connection負責處理一對request/response&lt;/p&gt;

&lt;p&gt;而實際上使用者可以控制瀏覽器的parallel tcp connections數，也就是決定TCP connection的建立是one by one或者可以一次建立多條，減少Response時間&lt;/p&gt;

&lt;h3 id=&#34;persistent&#34;&gt;Persistent&lt;/h3&gt;

&lt;p&gt;同上數步驟，區別在於所有Request/response 都由同一條connection處理，在一組response回傳後仍舊保持connection為開啟狀態，而同時若server端有其他web page也同樣可以透過此條connection回送給同樣的client端。requests是可以連續被發出的而不必等待pending request，若connection在特定時間區段無使用後就會關閉。&lt;/p&gt;

&lt;h2 id=&#34;http-message-format&#34;&gt;http message format&lt;/h2&gt;

&lt;h3 id=&#34;http-request-message&#34;&gt;http request message&lt;/h3&gt;

&lt;p&gt;想看request header message 可以透過devtool來觀看，以編輯文章頁面為例
第一行稱為&lt;code&gt;request line&lt;/code&gt;，包含了三個區塊，&lt;code&gt;method field、URL field、http version field&lt;/code&gt;，其餘部分則稱為&lt;code&gt;header lines&lt;/code&gt;，紀錄了一些資訊包含host，connection是否持續保持打開等等&lt;/p&gt;

&lt;p&gt;GET /articles/10210183/draft HTTP/1.1
Host: ithelp.ithome.com.tw
Connection: keep-alive
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,&lt;em&gt;/&lt;/em&gt;;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-TW,zh;q=0.9,en-US;q=0.8,en;q=0.7&lt;/p&gt;

&lt;h3 id=&#34;http-response-message&#34;&gt;http response message&lt;/h3&gt;

&lt;p&gt;想看response message 可以透過devtool來觀看，以編輯文章頁面為例
第一行稱為&lt;code&gt;status line&lt;/code&gt;，包含了三個區塊，&lt;code&gt;protocol version status code corresponding status message&lt;/code&gt;，其餘部分則稱為&lt;code&gt;header lines&lt;/code&gt;，紀錄了一些資訊包含host，connection是否持續保持打開等等、再來為&lt;code&gt;entity body&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;HTTP/1.1 200 OK
Access-Control-Allow-Headers: DNT,X-Mx-ReqToken,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Authorization
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Origin: *
Cache-Control: no-cache, private
Content-Encoding: gzip
Content-Type: text/html; charset=UTF-8
Date: Tue, 04 Dec 2018 06:23:24 GMT
Server: nginx/1.4.6 (Ubuntu)
X-Content-Type-Options: nosniff
X-Frame-Options: SAMEORIGIN
Content-Length: 13621
Connection: keep-alive&lt;/p&gt;

&lt;h2 id=&#34;cookies&#34;&gt;Cookies&lt;/h2&gt;

&lt;p&gt;Cookies允許網站用於追蹤使用者紀錄，主要構成有四部分&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;cookie header line in request message&lt;/li&gt;
&lt;li&gt;cookie header line in response message&lt;/li&gt;
&lt;li&gt;cookie file 存放於各個使用者的browser&lt;/li&gt;
&lt;li&gt;back-end database in the Web site&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;當今天使用者第一次進到某網站，發出request到server端之後，response回來會有一個項目為ser-Cookie: 1678(for example)，之後當使用者再次進入此網站時發出request時便會夾帶此cookie，server端便能透過此cookie值追蹤與此使用者相關的紀錄，包含瀏覽過哪些商品或者是點擊過哪些資訊等等，&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181204/201076704r4tWrwTXc.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181204/201076704r4tWrwTXc.png&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Transport Services</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/transportservice/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/transportservice/</guid>
      <description>

&lt;h2 id=&#34;transport-services-available-to-applications&#34;&gt;Transport Services Available to Applications&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;transport service&lt;/code&gt; 這邊主要區分了四個面向的&lt;code&gt;service&lt;/code&gt;大類，&lt;code&gt;Reliable Data transfer&lt;/code&gt;、&lt;code&gt;throughput&lt;/code&gt;、&lt;code&gt;timing&lt;/code&gt;、&lt;code&gt;security&lt;/code&gt;。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Reliable data transfer&lt;/code&gt; - 假使protocol提供受保證的data delivery service則為受信賴的，亦即就是此service保證了一旦data從sending process傳遞到socket時就已經保證此data一定會抵達receiving process而且無任何error，若無提供此服務，則data從sending process之後有可能永遠到達不了receiving process端，這行為能被 &lt;code&gt;loss-tolerant applications&lt;/code&gt;接受&lt;/li&gt;
&lt;li&gt;&lt;code&gt;throughput&lt;/code&gt; - transport提供了保證穩定傳輸速率的service，可以保證application能擁有的傳輸速度，Applications需要throughput requirements的類型又被稱為&lt;code&gt;bandwidth-sensitive applications&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timing&lt;/code&gt; - 提供了時間的保證，可以保證資料傳遞的時間間距，此service相對real-time application是重要的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;security&lt;/code&gt; - 提供資料安全性的service，提供加密以及解密data的服務&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;transport-services-provided-by-the-internet&#34;&gt;Transport Services Provided by the Internet&lt;/h2&gt;

&lt;p&gt;Internet(大部分為TCP/IP networks)提供了兩個協定&lt;code&gt;TCP&lt;/code&gt;、&lt;code&gt;UDP&lt;/code&gt;，當設計一個network application時的必做選擇之一為在此兩種協定中擇一，不同的協定提供了不同的服務，不同的應用程式也有不同的需求。&lt;/p&gt;

&lt;h3 id=&#34;tcp&#34;&gt;TCP&lt;/h3&gt;

&lt;p&gt;TCP model 包含了連結取向的設計服務以及提供了&lt;code&gt;reliable data transfer&lt;/code&gt;服務，TCP在client server端都擁有&lt;code&gt;transpoart-layer control information&lt;/code&gt;在實際進入應用層面的&lt;code&gt;message&lt;/code&gt;時啟動，也就是所謂的&lt;code&gt;handshaking procedure&lt;/code&gt;，在握手階段完成後&lt;code&gt;TCP connection&lt;/code&gt;存在於&lt;code&gt;sockets of the two process&lt;/code&gt;之間。&lt;/p&gt;

&lt;p&gt;TCP 以及 UDP 兩者皆沒有提供任何加密手段，但以&lt;code&gt;TCP&lt;/code&gt;而言，廣大社群開發了一套&lt;code&gt;SSL&lt;/code&gt;，用於加強於&lt;code&gt;TCP&lt;/code&gt;中的安全考量，但注意到&lt;code&gt;SSL&lt;/code&gt;並不屬於一種協定，跟TCP、UDP是不同的level，而只是&lt;code&gt;TCP&lt;/code&gt;的強化，將加密手段實作於&lt;code&gt;application layer&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt;的設計中包含了防堵塞機制，會在網路壅塞時，去控制&lt;code&gt;process&lt;/code&gt;的送出以避免packet loss的問題等等。&lt;/p&gt;

&lt;h3 id=&#34;udp&#34;&gt;UDP&lt;/h3&gt;

&lt;p&gt;相對於&lt;code&gt;tcp&lt;/code&gt;，UDP相對寬鬆並只提供最小限度的服務，沒有加密手段，沒有防堵塞機制，也沒有任何Connection過程，甚至也不保證資料的傳遞，&lt;/p&gt;

&lt;h2 id=&#34;application-layer-protocols&#34;&gt;Application-Layer Protocols&lt;/h2&gt;

&lt;p&gt;應用層的協定主要規範了，&lt;code&gt;types of messages exchanged&lt;/code&gt;、&lt;code&gt;syntax of the various message type&lt;/code&gt;、&lt;code&gt;semantics of the fields&lt;/code&gt;、&lt;code&gt;rules for determining how and when a process sends message and responds to messages&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有些應用層協定是已經在&lt;code&gt;RFCs&lt;/code&gt;被明確記錄了，也因此這些協定是存在於&lt;code&gt;public domain&lt;/code&gt;裡的，例如常見的&lt;code&gt;http&lt;/code&gt;，也就是說今天一個web application若遵守&lt;code&gt;http&lt;/code&gt;協定，他便能從任何遵守&lt;code&gt;http&lt;/code&gt;的&lt;code&gt;web server&lt;/code&gt;去要求檔案。而另一種常見的協定為，&lt;code&gt;email&lt;/code&gt;傳遞所遵守的&lt;code&gt;SMTP&lt;/code&gt;。而協定在一個web application組成的一小部分，但也是極重要的部分之一，通常web application的組成包括了，文檔格式(HTML)、Web browser、Webserver、application-layer protocols&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Network Application Architectures</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/networkapplicationarchitectures/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/networkapplicationarchitectures/</guid>
      <description>

&lt;h2 id=&#34;network-application-architectures&#34;&gt;Network Application Architectures&lt;/h2&gt;

&lt;p&gt;network architecture，一個開發者設計一個application時，如何被架構在各個end system，而現今常見的net work application主要應用的兩個主流設計為&lt;code&gt;client-server architecture&lt;/code&gt;以及&lt;code&gt;peer-to-peer architecture (P2P)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;client-server-architecture&#34;&gt;client-server architecture&lt;/h3&gt;

&lt;p&gt;最終端永遠會存在於一台或以上的&lt;code&gt;host&lt;/code&gt;，所謂的&lt;code&gt;server&lt;/code&gt;，負責處理從其他end system傳來的&lt;code&gt;service request&lt;/code&gt;，也就是所謂的&lt;code&gt;client&lt;/code&gt;，最明顯的特徵是，&lt;code&gt;clients&lt;/code&gt;之間並不能直接溝通傳遞訊息，必須得經由最上游的&lt;code&gt;host&lt;/code&gt;來運作，另一個特點是&lt;code&gt;server&lt;/code&gt;存在固定的&lt;code&gt;IP Address&lt;/code&gt;，地址永遠是固定的而且server持續維持運作的狀態下，client便可以透過這樣的服務傳遞封包。&lt;/p&gt;

&lt;p&gt;通常如常見的大型社群網站，會擁有&lt;code&gt;data center&lt;/code&gt;，安放大量的&lt;code&gt;hosts&lt;/code&gt;來做為一個強大的server，處理大量的用戶request，而因此也必須額外付出從&lt;code&gt;data center&lt;/code&gt;到各個&lt;code&gt;host&lt;/code&gt;的連線以及頻寬成本。&lt;/p&gt;

&lt;h3 id=&#34;peer-to-peer-architecture-p2p&#34;&gt;peer-to-peer architecture (P2P)&lt;/h3&gt;

&lt;p&gt;P2P並沒有絕對依賴指定的&lt;code&gt;host&lt;/code&gt;，不同於前者，&lt;code&gt;clients&lt;/code&gt;在一組相互連結的&lt;code&gt;hosts中&lt;/code&gt;可以直接與彼此溝通，稱為&lt;code&gt;peers&lt;/code&gt;，&lt;code&gt;peers&lt;/code&gt;並不屬於&lt;code&gt;service provider&lt;/code&gt;而是各個&lt;code&gt;users hosts&lt;/code&gt;，也就是不用轉折點的&lt;code&gt;server&lt;/code&gt;去執行。&lt;/p&gt;

&lt;p&gt;很明顯一項特點就是&lt;code&gt;self-scalability&lt;/code&gt;，雖然每一個peers在request時都會產生workload，但同時也提升了service capacity，也就是說，每當一個&lt;code&gt;peer&lt;/code&gt;加入時，整個P2P架構的系統，就會多增加一個&lt;code&gt;peer&lt;/code&gt;提供的資源、頻寬以及計算能力，但同時越多使用者的話，傳輸的效率也會越慢，此外，由於不需通過指定&lt;code&gt;server&lt;/code&gt;的運作，也省去了從&lt;code&gt;host -&amp;gt; server&lt;/code&gt;的頻寬以及服務功能。&lt;/p&gt;

&lt;p&gt;方便的同時也須注意三個隱憂&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;ISP Friendly - 大部分的地區ISPs已經切割好指定的頻寬使用，為了準備應付更多的&lt;code&gt;downstream than upstream traffic&lt;/code&gt;，而&lt;code&gt;P2P&lt;/code&gt;的設計則會把佔頻寬的&lt;code&gt;upstream traffic&lt;/code&gt;從&lt;code&gt;server&lt;/code&gt;搬移至&lt;code&gt;ISPs&lt;/code&gt;運作，造成ISPs更大的負擔，因此在設計上得納入考量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Security - 顯而易見的彼此users都是open的，所以也很容易遭受到惡意攻擊。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Incentives - 以P2P的設計來說，得吸引使用者去提供自己的頻寬、儲存空間以及資源。
&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181128/20107670oq8R6uBKYo.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181128/20107670oq8R6uBKYo.png&#34; /&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;process-communicating&#34;&gt;Process Communicating&lt;/h2&gt;

&lt;p&gt;process可以想像成，一隻program在end system上執行，Processes在兩台不同的end systems上主要透過&lt;code&gt;messages&lt;/code&gt;的交換來溝通。&lt;/p&gt;

&lt;h3 id=&#34;client-and-server-process&#34;&gt;Client and Server Process&lt;/h3&gt;

&lt;p&gt;Network application 都會有&lt;code&gt;一組processes&lt;/code&gt;組成，透過network傳送&lt;code&gt;messages&lt;/code&gt;給彼此，通常會將兩個processes一個定義為clicent另一個為server，以常見的google為例，我們的&lt;code&gt;browser&lt;/code&gt;就是一個&lt;code&gt;client process&lt;/code&gt;發送&lt;code&gt;request message&lt;/code&gt;給&lt;code&gt;server process&lt;/code&gt;接收並給予回應，在&lt;code&gt;P2P&lt;/code&gt;的設計上來說，&lt;code&gt;peer&lt;/code&gt;可以同時為&lt;code&gt;client&lt;/code&gt;與&lt;code&gt;server&lt;/code&gt;，有一個定義是指&lt;code&gt;觸發訊息交換的process&lt;/code&gt;為&lt;code&gt;client&lt;/code&gt;，而等待被聯絡的&lt;code&gt;process&lt;/code&gt;則為&lt;code&gt;server&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-interface-between-the-process-and-the-computer-network&#34;&gt;The Interface Between the Process and the Computer Network&lt;/h3&gt;

&lt;p&gt;所有&lt;code&gt;message&lt;/code&gt;從process出發到接收一定會經過&lt;code&gt;network&lt;/code&gt;，而透過將&lt;code&gt;process message&lt;/code&gt;傳遞到&lt;code&gt;network&lt;/code&gt;的介面就是&lt;code&gt;socket&lt;/code&gt;，也被稱為&lt;code&gt;API&lt;/code&gt;。可以記為&lt;code&gt;socket&lt;/code&gt;為&lt;code&gt;application layer &amp;amp; transpoart layer&lt;/code&gt;的&lt;code&gt;interface&lt;/code&gt;，通常開發者會在application-layer side of the socket 擁有比較多的控制權，反之在transport-layer side便沒有太大的操作空間。&lt;/p&gt;

&lt;p&gt;後者主要有兩種，
1. 選擇transport protocol，如果有選擇是available的話
2. 或許有機會去調整少數transport-layer parameters如最大buffer以及最大segment size&lt;/p&gt;

&lt;h3 id=&#34;addressing-processes&#34;&gt;Addressing Processes&lt;/h3&gt;

&lt;p&gt;傳遞訊息主要需要兩個已知的資訊，一者為receive host 的 address，二者為辨別receiving process的身分證，通常前者為host IP address。一般而言，一台host可能會在多個network applications上，為了辨別出指定的&lt;code&gt;receiving socket&lt;/code&gt;，需要&lt;code&gt;port number&lt;/code&gt;來達成，而這也有一個常見的規範port number表 &lt;a href=&#34;http://www.iana.org&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;於此&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Network Attack</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/networkattack/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/networkattack/</guid>
      <description>

&lt;h2 id=&#34;networks-under-attack&#34;&gt;Networks under attack&lt;/h2&gt;

&lt;h3 id=&#34;malware-惡意軟體&#34;&gt;malware 惡意軟體&lt;/h3&gt;

&lt;p&gt;透過Internet的傳遞，我們的機器很可能被有意地傳送惡意軟體，例如以前常見的&lt;code&gt;email&lt;/code&gt;釣魚信件，一旦我們的本機成為了受侵入的&lt;code&gt;compromised host&lt;/code&gt;，就也有極大可能被hackers拿來當作&lt;code&gt;botnet&lt;/code&gt;，繼續散步惡意軟體。&lt;/p&gt;

&lt;p&gt;多數的惡意軟體都是能自我增值的，也就是一旦有一台主機被侵入，惡意軟體就可以根據被侵入的主機繼續尋找可以侵入下一台主機的機會，也因此惡意軟體一旦散布出去後，是成指數成長的。常見的惡意軟體主要分為兩種&lt;code&gt;type&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Virus&lt;/code&gt; - 必須透過&lt;code&gt;使用者的互動&lt;/code&gt;才會受到侵入，例如釣魚信件裡的附件，開啟附件後才會被侵入。
&lt;code&gt;Worm&lt;/code&gt;  - 不必使用者互動就有可能受到侵入，例如在不安全的網站下，就有可能遭受到攻擊。&lt;/p&gt;

&lt;h3 id=&#34;dos-attacks-denial-of-service&#34;&gt;Dos attacks (denial-of-service)&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Dos attack&lt;/code&gt;攻擊network的服務，讓合法使用者無法正常使用network service。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Vulnerability attack&lt;/code&gt; - 在netowrk過程中塞入惡意message，當packet順序偶然按照惡意訊息的順序接受到，就會受到惡意攻擊。
&lt;code&gt;Bandwidth flooding&lt;/code&gt; - 送出海量的垃圾封包，讓目標host的packet堵塞，讓其訊息無法送達server
&lt;code&gt;Connection flooding&lt;/code&gt; - 在target host建立大量開放式或半開放式的TCP connections，讓封包進入這些意的connection之後就中斷了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;DDoS&lt;/code&gt; - 則是應用第二種攻擊方式，由單一source傳送大量垃圾封包是容易被發現並被阻擋的，而DDoS則是透過一台source將海量封包分配到&lt;code&gt;botnet&lt;/code&gt;下再由這群botnet送至&lt;code&gt;destination&lt;/code&gt;，造成堵測的問題&lt;/p&gt;

&lt;h3 id=&#34;sniff&#34;&gt;Sniff&lt;/h3&gt;

&lt;p&gt;在現代網路access方便的年代，例如Wifi，同時也隱藏的網路安全危機，由於只要在附近的的人都可以連取到，同一個發收器訊號，也意味著，當訊息傳遞時，附近所有的人同時也是&lt;code&gt;passive receiver&lt;/code&gt;有權去記錄&lt;code&gt;copy of packet&lt;/code&gt;，若包含重要的隱私訊息也同樣會被複製下來，而較常見的解法變是加密，待&lt;code&gt;packet&lt;/code&gt;到目的地時在解密。由於這種手法是被動接受的，相對難以偵測。&lt;/p&gt;

&lt;h3 id=&#34;masquerade&#34;&gt;masquerade&lt;/h3&gt;

&lt;p&gt;透過自己製作一個封包並帶著&lt;code&gt;false ip address&lt;/code&gt;，送入internet裡面傳遞，在&lt;code&gt;route&lt;/code&gt;的接受過程中，是有可能把&lt;code&gt;人工的packet&lt;/code&gt;認為是可信任的封包，並繼續接下來的SOP。而這也能達成偽裝成其他使用者的目的，通常這種把帶有假IP address的packet注入到Internet裡面稱之為&lt;code&gt;IP spoofing&lt;/code&gt;，是偽裝方式中常見的的一種方式。&lt;/p&gt;

&lt;p&gt;要防範此種行為，便是在&lt;code&gt;end-point&lt;/code&gt;加上驗證的階段，有了驗證的機制去確認此封包到底是不是我們所認為的封包。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Network Layer</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/networklayerbrief/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/networklayerbrief/</guid>
      <description>

&lt;h2 id=&#34;brief-intro-about-five-layers&#34;&gt;Brief-intro about Five Layers&lt;/h2&gt;

&lt;p&gt;層級的概念是，個別層級中有自己的服務，個別執行特定的動作已達成目標，而傳遞下去的層級中，是依賴於上一層的服務，舉例來說的話，買票之後才能上火車，第一層的服務為窗口買票，第二層為上車的動作，若第一層沒買票的話，則第二層便無法實現。&lt;/p&gt;

&lt;p&gt;從上到下的五層順序分別為 &lt;code&gt;Application Layer&lt;/code&gt;、&lt;code&gt;Transport Layer&lt;/code&gt;、&lt;code&gt;Network Layer&lt;/code&gt;、&lt;code&gt;Link&lt;/code&gt;、&lt;code&gt;Physical&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;application-layer&#34;&gt;Application Layer&lt;/h3&gt;

&lt;p&gt;應用層是最接近web app的，此層的協定包含常見
&lt;code&gt;Http&lt;/code&gt; - 提供向瀏覽器發出request &amp;amp; transfer
&lt;code&gt;SMTP&lt;/code&gt; - 提供transfer&lt;code&gt;email&lt;/code&gt;訊息
&lt;code&gt;FTP&lt;/code&gt;  - 提供檔案的傳輸協定
&lt;code&gt;DNS&lt;/code&gt;  - 提供轉換網址到&lt;code&gt;network address&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;應用層協定分布於各個end system上，各個end system透過傳輸層提供的protocol去交換packet。&lt;/p&gt;

&lt;h3 id=&#34;transport-layer&#34;&gt;Transport Layer&lt;/h3&gt;

&lt;p&gt;主要將應用層傳遞下來的封包，透過TCP/UDP協定傳送，在此處也會在packet上加上header information，包含了允許封包在receiver那邊可以往上丟回&lt;code&gt;application layer&lt;/code&gt;，以及&lt;code&gt;errr-detection bits&lt;/code&gt;讓receiver知道message是否在route理被動過手腳&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt; - 提供&lt;code&gt;messages&lt;/code&gt;的傳送以及flow control，也提供將&lt;code&gt;packet&lt;/code&gt;切成&lt;code&gt;segment&lt;/code&gt;，以及&lt;code&gt;packet&lt;/code&gt;塞車的處理機制
&lt;code&gt;UDP&lt;/code&gt; - 提供了當無網路狀態時web app的service&lt;/p&gt;

&lt;h3 id=&#34;network-layer&#34;&gt;Network Layer&lt;/h3&gt;

&lt;p&gt;負責整個封包傳遞流程的&lt;code&gt;datagrams&lt;/code&gt;，主要為&lt;code&gt;IP protocol&lt;/code&gt;，定義了&lt;code&gt;datagrams&lt;/code&gt;的區域以及end system &amp;amp; router如何在這些fields做行為，特別注意到&lt;code&gt;IP protocol&lt;/code&gt;只有唯一一個，所有&lt;code&gt;Internet component&lt;/code&gt;一定都得遵守，同時此層也包含許多&lt;code&gt;routing protocols&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;link-layer&#34;&gt;Link Layer&lt;/h3&gt;

&lt;p&gt;將&lt;code&gt;packet&lt;/code&gt;從node中運輸依賴的是&lt;code&gt;link layer&lt;/code&gt;的服務，負責傳送network層的datagram到下一個node節點。此服務依賴於&lt;code&gt;link-layer protocol&lt;/code&gt;，常見的link-layer protocol為以下&lt;code&gt;Ethernet Wifi DOCSIS&lt;/code&gt;等等，同一組&lt;code&gt;datagram&lt;/code&gt;可能會在不同的Route被不同的協定服務，通常在&lt;code&gt;link-layer&lt;/code&gt;的&lt;code&gt;packet&lt;/code&gt;又稱為&lt;code&gt;frames&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;physical-layer&#34;&gt;physical Layer&lt;/h3&gt;

&lt;p&gt;就幾乎是實體線路的範圍了，在此不做贅述&lt;/p&gt;

&lt;h2 id=&#34;encapsulation&#34;&gt;Encapsulation&lt;/h2&gt;

&lt;p&gt;封包在傳遞的過程中，所經過的layer並不相同，如下圖所示，在link-layer switch以及router裡面，packet作用的service在後面三層，而在end system才有到頭兩層，在層數往下的過程中，都會加入header information作為保護的手段，如圖中的Ht、Hn，因此我們可以依圖所例，得知每個層級都會有兩個type of fields，一者為前一層帶下來的packet，一者為每層級的header information。&lt;/p&gt;

&lt;p&gt;以一個假設來說，今天A想要寄信到B，首先&lt;code&gt;A手寫的信&lt;/code&gt;，也就是&lt;code&gt;application-layer message&lt;/code&gt;，會先裝到&lt;code&gt;信封袋&lt;/code&gt;中，並寫上&lt;code&gt;B的住址以及姓名&lt;/code&gt;，整個信封袋就是&lt;code&gt;transport-layer segment&lt;/code&gt;，封裝了&lt;code&gt;application-layer message&lt;/code&gt;，接著到郵局之後，經郵局分類放到&lt;code&gt;對應的縣市分類夾&lt;/code&gt;，也就是&lt;code&gt;datagram&lt;/code&gt;他封裝了&lt;code&gt;trsans-layer segment&lt;/code&gt;，接著郵差開始從&lt;code&gt;分類夾中拿出信件&lt;/code&gt;，並對照&lt;code&gt;上面的資訊送到B的家裡&lt;/code&gt;，也就是解封的過程開始，最後B成功收到信上的內容。&lt;/p&gt;

&lt;p&gt;由此可見，在每個層級都會在封裝前個層級的封包，這就是封裝的概念。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20107670udmOwQ5j7i.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181113/20107670udmOwQ5j7i.png&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Packet Probrlm</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/packetproblm/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/packetproblm/</guid>
      <description>

&lt;h1 id=&#34;delay-loss-throughtput&#34;&gt;Delay, Loss, Throughtput&lt;/h1&gt;

&lt;h2 id=&#34;types-of-dealy&#34;&gt;Types of Dealy&lt;/h2&gt;

&lt;p&gt;假使今天sourceA丟出一個封包道destinationB，途中可能會經過routerA、routerB，當&lt;code&gt;packet&lt;/code&gt;運送到&lt;code&gt;routerA&lt;/code&gt;時，routerA會有一條&lt;code&gt;outbound link&lt;/code&gt;到routerB，進到此link前會有一個queue，判斷當前是否有其他&lt;code&gt;packet&lt;/code&gt;，是否正在此&lt;code&gt;link&lt;/code&gt;傳輸資訊。所以今天&lt;code&gt;new packet&lt;/code&gt;送到routerA時，routerA會根據&lt;code&gt;header&lt;/code&gt;資訊決定將&lt;code&gt;new packet&lt;/code&gt;安排到特定&lt;code&gt;link&lt;/code&gt;，當&lt;code&gt;link&lt;/code&gt;有數據正在傳輸時，new packet便會進到queue裡面去等待。&lt;/p&gt;

&lt;h3 id=&#34;processing-delay&#34;&gt;Processing Delay&lt;/h3&gt;

&lt;p&gt;解讀&lt;code&gt;packet header&lt;/code&gt;並解決定此&lt;code&gt;packet&lt;/code&gt;map到特定&lt;code&gt;link&lt;/code&gt;的時間就是process delay，通常在routers裡面，此種delay的時間大概落於&lt;code&gt;microseconds or less&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;queuing-delay&#34;&gt;Queuing Delay&lt;/h3&gt;

&lt;p&gt;就字面上的意思，當&lt;code&gt;packet 進到queue&lt;/code&gt;裡面，等待其他先到達的packet完成傳輸的時間成本就是Queuing Delay，通常此delay的時間實務上落於&lt;code&gt;microseconds to milliseconds&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;transmission-delay&#34;&gt;Transmission Delay&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;packet&lt;/code&gt;傳輸到&lt;code&gt;link&lt;/code&gt;的所耗費時間，假使今天&lt;code&gt;packet&lt;/code&gt;有L bits，&lt;code&gt;link&lt;/code&gt;的 transmission rate R bits/sec，那麼transmission delay的時間便是 L/R，此delay的時間實務上落於&lt;code&gt;microseconds to milliseconds&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;與propagation delay區別的話，&lt;code&gt;transmission delay&lt;/code&gt;為packet中的每個bit從link到router裡面組好完成一個packet後的等待時間，假使今天有一個packet中包含十個bit，十個bit分別排隊等待進入router，而第一個bit通過router後仍然得在router裡面等待另外九個bit來後組成一個packet才能往下一個router前進，十個bit調router的時間就是&lt;code&gt;transmission delay&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;propagation-delay&#34;&gt;Propagation Delay&lt;/h3&gt;

&lt;p&gt;從&lt;code&gt;link&lt;/code&gt;將資料傳遞到&lt;code&gt;router&lt;/code&gt;的時間成本，&lt;code&gt;Propagation speed&lt;/code&gt;主要影響為實體的線路，指的是一個&lt;code&gt;packet&lt;/code&gt;從&lt;code&gt;router&lt;/code&gt;到&lt;code&gt;router&lt;/code&gt;的時間，而影響此數據的實際因素為&lt;code&gt;router&lt;/code&gt;間的&lt;code&gt;distance&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;traffic-intensity&#34;&gt;Traffic intensity&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Traffic intensity&lt;/code&gt; 代表的是每秒傳送到&lt;code&gt;queue的密集度&lt;/code&gt;，假設今天有&lt;code&gt;X&lt;/code&gt;個packets，每個packets皆由&lt;code&gt;Y bits&lt;/code&gt;組成，而若&lt;code&gt;transmission rate&lt;/code&gt;為&lt;code&gt;Z bits/sec&lt;/code&gt;，則密集度為&lt;code&gt;XY/Z&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此密集度通常用來評估&lt;code&gt;queueing dealy&lt;/code&gt;的長度，若&lt;code&gt;Traffic intensity &amp;gt; 1&lt;/code&gt;也就是每次進來排隊的packet大於送出去的packet，那麼queue就會無限長，因此最最最基本的設計為，&lt;code&gt;Design your system so that the traffic intensity is no greater than 1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;當&lt;code&gt;Traffic intensity &amp;lt;= 1&lt;/code&gt;時，第一，若是packet到達的時間剛好等同於出去的時間，也就是 X/Z，那麼就不會有queue的產生，反之，若packets於短時間大量到達，假使N packet在 (X/Z)N的速率到達，今天若有三個，澤第一個packet不用等待，而第二個就得等待(X/Z)(2-1)，第三個就得等待(X/Z)(3-1)的時間。&lt;/p&gt;

&lt;p&gt;簡單來說，&lt;code&gt;Traffic intensity&lt;/code&gt;越接近或大於1時，&lt;code&gt;queueing delay&lt;/code&gt;就越大，反之則越小&lt;/p&gt;

&lt;h2 id=&#34;throughput&#34;&gt;Throughput&lt;/h2&gt;

&lt;p&gt;HostA傳送檔案到HostB的完整時間，也就是每秒傳輸量，主要影響為communication link的 Transmission rate，若單純只有A到B，則&lt;code&gt;Throughput&lt;/code&gt;為min(Ra,Rb)，也就是router到A以及Router到B的最小值，若common rate為R，有十台機器連到server，Server to router 為Ra，Router to destination為Rd，若 R/10小於Ra、Rd，則Throughput為R，若遠大於Ra、Rd，則為min(Ra,Rd)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Switching</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/switching/</link>
      <pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/switching/</guid>
      <description>

&lt;h3 id=&#34;packet-switching-vs-circuit-switching&#34;&gt;Packet switching vs Circuit Switching&lt;/h3&gt;

&lt;p&gt;主要差別在於，前者並不會保留&lt;code&gt;特定path&lt;/code&gt;，而後者會&lt;code&gt;保留一個特定path&lt;/code&gt;給package。因此當&lt;code&gt;packet switching&lt;/code&gt;同時遇到太多package進來時，就得進入到buffer裡面去排隊，等待安排output communication，&lt;code&gt;Circuit Switching&lt;/code&gt;則不必等待，而是在進來之前已經先預訂好path，而因此，也必須在兩個end system裡面先建立好connection之後才能進行資料傳輸動作，而相對也有比較穩定的傳輸速率。&lt;/p&gt;

&lt;p&gt;範例來說，如果今天有N個使用者的話，套用&lt;code&gt;circuit switching&lt;/code&gt;的方法可能最高只能容納10個使用者同時運作，因為會預先保留頻寬給user，當user可能還沒進行傳輸時，就會一直保留住，導致於後面進來的user，得一直卡在buffer裡面，有種占著茅坑不拉屎的感覺。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;packet switching&lt;/code&gt;則不會保留頻寬，只要有空位使用者便進來使用而且傳輸，今天若同時有十個人進到餐廳裡面，但有五個人還沒開始用餐的話，packet switching則會先把五個座位安排給可以馬上用餐的人，所以相對&lt;code&gt;circuit switching&lt;/code&gt;來說，就不會有被佔住位置的問題。當然如果五個user都佔據超大數據傳輸資料的話，仍然會有buffer塞爆的問題了&lt;/p&gt;

&lt;h3 id=&#34;tdm-fdm&#34;&gt;TDM &amp;amp; FDM&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;TDM&lt;/code&gt;是將一個connection的duration切成&lt;code&gt;frame&lt;/code&gt;，每個&lt;code&gt;frame&lt;/code&gt;中在切出&lt;code&gt;time slot&lt;/code&gt;，User開始傳遞資訊時便會被塞到&lt;code&gt;time slot&lt;/code&gt;，也就是在一個固定的時間內切割頻寬，同時允許多個使用者傳遞資料，&lt;code&gt;time slot&lt;/code&gt;越多，相對地速率也會趨緩。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;FDM&lt;/code&gt;則是依頻率來切割link區段，而使用者同時在同一個切割區域裡面做傳輸，不同於&lt;code&gt;TDM&lt;/code&gt;是一個一個將使用者塞到slot裡面去做動作，FDM是一起將user丟到一個pool的感覺。&lt;/p&gt;

&lt;h3 id=&#34;networks-of-networks&#34;&gt;networks of networks&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181025/20107670FFexMX3gjC.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181025/20107670FFexMX3gjC.png&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Protocol</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetpacket/</link>
      <pubDate>Tue, 02 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetpacket/</guid>
      <description>

&lt;h2 id=&#34;protocol&#34;&gt;Protocol&lt;/h2&gt;

&lt;p&gt;協定的存在就像是人類的語言，不同的語言交流一定會有障礙，若不是大家遵守同一套協定，說著不同的語言，那是無法溝通的，所以Protocol的存在就是讓兩台機器有一個交流的共識，如此才能辨識送過來的請求以及回送相對應的回覆，已完成我們想要達成的目的，例如從clint side 打API 從server side得到相對應的資料，中間的請求與回覆就得有一個協定存在。&lt;/p&gt;

&lt;h3 id=&#34;network-protocols&#34;&gt;Network Protocols&lt;/h3&gt;

&lt;p&gt;網路協定的動作是由&lt;code&gt;software or hardware&lt;/code&gt;執行，也就是我們的電腦、手機、路由器等等，所有在Internet上的包含&lt;code&gt;兩個或以上&lt;/code&gt;遠端機器的行為都會由協定來管理監控，以一個例子來說，當我們對&lt;code&gt;Web server&lt;/code&gt;發出請求時，也就是輸入一個&lt;code&gt;URL到Browser&lt;/code&gt;時，我們會先從自己的&lt;code&gt;電腦發送一個request至Web server&lt;/code&gt;，&lt;code&gt;Web server&lt;/code&gt;接收到請求時會根據&lt;code&gt;request message&lt;/code&gt;去給出一個回應&lt;code&gt;replay message&lt;/code&gt;，接著我們的電腦收到&lt;code&gt;OK&lt;/code&gt;的reply後，已&lt;code&gt;GET message 丟出我們輸入的URL撈取相對應的document&lt;/code&gt;，接著&lt;code&gt;Web server&lt;/code&gt;回傳我們要的Web page回到computer顯現。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20180920/20107670oVZPcXGEKU.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20180920/20107670oVZPcXGEKU.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;protocol&lt;/code&gt;定義了整個溝通流程的SOP，包含初始步驟是傳遞request以及收到reply，採取什麼動作或者針對不同事件做出不同回應等，不同的&lt;code&gt;protocol&lt;/code&gt;在不同的情境使用以達成不同的&lt;code&gt;communication tasks&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;access-network&#34;&gt;Access Network&lt;/h2&gt;

&lt;h3 id=&#34;home-access-dsl-cable-ftth-dial-up-and-satellite&#34;&gt;Home access: DSL, Cable, FTTH, Dial-Up, and Satellite&lt;/h3&gt;

&lt;p&gt;目前一般家庭最常見連結網路的方式為透過&lt;code&gt;DSL &amp;amp; Cable&lt;/code&gt;，DSL就等同於透過電信公司提供連結管道，包含了電話與網路的ISPs，也就是中華電信那台數據機，有點像是電信公司透過電話線切割兩條線路出來，一條給家用電話，另一條就是給DSL數據機提供上網，所以大家可以理解到十年前每次有電話來就會斷網路的情況就是電話線路的切割部分沒處理好。&lt;/p&gt;

&lt;p&gt;所以大概的架構就是家用的電話訊號以及網路訊號會傳送回電信公司也就是&lt;code&gt;DSLAM&lt;/code&gt;去送回&lt;code&gt;Internet&lt;/code&gt;以及&lt;code&gt;Telephone network&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;network-core&#34;&gt;Network Core&lt;/h2&gt;

&lt;h3 id=&#34;store-andforward-transmission&#34;&gt;Store-andForward Transmission&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;packet switch&lt;/code&gt;在接收到整個完整data拆散後的封包才開始傳送&lt;code&gt;first bit&lt;/code&gt;到外部link，也就是source -&amp;gt; router -&amp;gt; destination，source data如果切成了 packetA、packetB、packetC，在A到達之後仍會先被儲存到&lt;code&gt;router(packet switch)&lt;/code&gt;待三個封包都到達之後才送往outputlink。&lt;/p&gt;

&lt;h3 id=&#34;queuing-delays-and-packet-loss&#34;&gt;Queuing Delays and Packet Loss&lt;/h3&gt;

&lt;p&gt;通常每個packet switch 會有連結許多communication links，對於每個link，packet switch會有一個&lt;code&gt;output buffer&lt;/code&gt;，當packet傳送中又有另外一個packet到達時，剛到達的packet則會被放入buffer中排隊，等待傳到link上，因此就會有&lt;code&gt;queuing Delay&lt;/code&gt;的問題。&lt;/p&gt;

&lt;p&gt;而&lt;code&gt;packet loss&lt;/code&gt;則是因為&lt;code&gt;buffer&lt;/code&gt;區域的空間有限，當塞爆的時候，可能是剛到達的packet被丟棄，或者是在queue等待的某個packet被丟棄。&lt;/p&gt;

&lt;h3 id=&#34;forwarding-tables-and-routing-protocols&#34;&gt;Forwarding Tables and Routing Protocols&lt;/h3&gt;

&lt;p&gt;packet switches 如同之前所講的，有許多連結的接收communication links &amp;amp; output links，那麼router是怎麼決定這些link的使用?&lt;/p&gt;

&lt;p&gt;每個end system都擁有一個&lt;code&gt;IP address&lt;/code&gt;，當一台source -&amp;gt; destination 的過程中，這個destination位址也會一起被放在&lt;code&gt;packet header&lt;/code&gt;裡面，在router根據位址匹配到鄰近的router裡面，更精準地來說，&lt;code&gt;每個router&lt;/code&gt;都擁有一個&lt;code&gt;forwarding table&lt;/code&gt;對應&lt;code&gt;destination address&lt;/code&gt;的&lt;code&gt;outbound links&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;感覺有點像是在問路，假設我想從台北開車到高雄，在桃園加油站(第一個router)，詢問店員該走哪條高速公路(forwarding table)，接著又到台中加油站做同樣的行為，這個詢問的動作就像是&lt;code&gt;router&lt;/code&gt;對照&lt;code&gt;forwarding table&lt;/code&gt;，最後到達目的地。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20181002/20107670mJZx9rwbFq.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20181002/20107670mJZx9rwbFq.png&#34; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Internet Basic</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetbasic/</link>
      <pubDate>Wed, 19 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetbasic/</guid>
      <description>

&lt;h2 id=&#34;internet&#34;&gt;Internet&lt;/h2&gt;

&lt;p&gt;Internet主要大概流向為 ISPs -&amp;gt; routers -&amp;gt; Moerdem -&amp;gt; routers -&amp;gt; end system, base station等等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;packet&lt;/code&gt;為封包，透過&lt;code&gt;目標host&lt;/code&gt;將傳輸的資料轉成片段的封包，並在header 加上bytes，類似於加密的功能，網路上的資訊都是透由&lt;code&gt;packet&lt;/code&gt;傳遞。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;communication links&lt;/code&gt;封包的接受與傳送主要透過此links連結，在&lt;code&gt;packet switches&lt;/code&gt;裡面會從多個&lt;code&gt;incoming communication links&lt;/code&gt;之一挑選一個接收封包，再由多個&lt;code&gt;outgoing communication links&lt;/code&gt;傳送封包出去，兩者的運用就是主要封包的傳遞路程，最後送到欲到達的&lt;code&gt;end sysystem&lt;/code&gt;裡面重新解密原始資料。&lt;/p&gt;

&lt;p&gt;而整個從第一個&lt;code&gt;end system&lt;/code&gt;丟出封包到另一台&lt;code&gt;end system&lt;/code&gt;的過程稱為一個&lt;code&gt;route || path&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://ithelp.ithome.com.tw/upload/images/20180919/20107670bKCkgJ2cTo.png&#34; alt=&#34;https://ithelp.ithome.com.tw/upload/images/20180919/20107670bKCkgJ2cTo.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;網路資訊的傳遞過程就像是貨物運送流程，&lt;code&gt;packet&lt;/code&gt;就像是一台卡車，負責載著貨物(&lt;code&gt;data&lt;/code&gt;)到目的地，&lt;code&gt;communication links&lt;/code&gt;則是卡車行駛的道路或者高速公路，&lt;code&gt;packet switches&lt;/code&gt;則像是中繼站或者十字路口，負責決定將封包分配到目的地，也就是&lt;code&gt;end system&lt;/code&gt;並卸載，而整個配送過程就是一個&lt;code&gt;route || path&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;當今最主要的&lt;code&gt;packet switches&lt;/code&gt;方式為&lt;code&gt;router &amp;amp; link-layer switches&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;router 主要使用在network core裡面&lt;/li&gt;
&lt;li&gt;link-layer switches 通常使用於access network上&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;tcp-ip&#34;&gt;TCP/IP&lt;/h2&gt;

&lt;p&gt;目前 Internet 最重要的兩個協定，&lt;code&gt;IP&lt;/code&gt;主要是規範於封包在&lt;code&gt;router &amp;amp; end system&lt;/code&gt;傳遞過程中的格式。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;API&lt;/code&gt;指的是一組規則，傳送資料的program必須得遵守此規則，Internet才能准許傳送data到指定的目的地，以寄信來做個比喻的話，假設A要寄信給B，不可能只把信寫好，丟在門口，信就會自動到達位置的吧?&lt;/p&gt;

&lt;p&gt;寄信的過程得必須遵守，將信放置信封袋，寫上收件人、收件地址、貼上郵票，丟到郵箱丟到郵筒後才會準確寄出，相同於API，program傳送資訊必須遵守一定的規範才能透過API傳送資料到另一台end system。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.pearson.com/us/higher-education/product/Kurose-Computer-Networking-A-Top-Down-Approach-6th-Edition/9780132856201.html&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Computer Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>prototype</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day25_prototype3/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day25_prototype3/</guid>
      <description>

&lt;h2 id=&#34;constructors-prototype&#34;&gt;Constructors &amp;amp; prototype&lt;/h2&gt;

&lt;p&gt;前面我們提到了prototype的概念，也知道了物件裡的prototype chain是怎麼回事，我們回想一下創造物件的方式有哪些，除了一般的宣告，還有一個在function介紹的方式，也就是constructor，那透過constructor創立的物件如何去設定它的prototype呢?&lt;/p&gt;

&lt;p&gt;今天我們就來探討一下這個問題&lt;/p&gt;

&lt;h2 id=&#34;one-for-all-all-or-one&#34;&gt;One for all &amp;amp; All or one&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;function User(name, friends) {

	this.name = name;
	this.friends = friends;
	this.greet = function() {
		console.log(&#39;Welcome&#39; + this.name);
	}

}

var userA = new User(&#39;Bob&#39;, [&#39;Ben&#39;, &#39;Andy&#39;]);


console.log(userA.__proto__); // {constructor User}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;當我們透過function 建立物件時，在new的時候Javascript Engine就會自動幫我們建立好prototype chain，新建的物件會有一條prototype chain連結到constructor。&lt;/p&gt;

&lt;h3 id=&#34;special-property&#34;&gt;Special Property&lt;/h3&gt;

&lt;p&gt;回想一下，我們說過每一個物件都有自己的一個property叫做prototype吧，而所有函式之中也有一個特殊的property，這也是我們把函式當作constructor使用時應該要注意並好好運用的一個special property。&lt;/p&gt;

&lt;p&gt;&lt;img style=&#34;width:100%;height:auto;padding:10px&#34; src=&#34;../images/prototype12.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;每個函式雖然都有prototype這個property，但除了function constructor，一般函式是不會用到這個property的。就只有 ! 當今天把函式用來建立新物件的時候，這個Property才會被使用到。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function User(name, friends) {

	this.name = name;
	this.friends = friends;
	this.greet = function() {
		console.log(&#39;Welcome&#39; + this.name);
	}

}

User.prototype.welcome = function() {
	return &#39;Hi&#39; + &#39; &#39; + this.name;
}

var userA = new User(&#39;Bob&#39;, [&#39;Ben&#39;, &#39;Andy&#39;]);


console.log(userA.__proto__);
console.log(userA.welcome()); //Hi Bob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今天new建立一個空物件時候，同時也將空物件的prototype指到後面函式的prototype property，也就是此時空物件的prototype是指到 User.prototype的，所有透過此constructor的新物件，其prototype都會指到此函式的prototype property。&lt;/p&gt;

&lt;p&gt;所以上面範例的結果會變成下圖。
&lt;img style=&#34;width:100%;height:auto;padding:10px&#34; src=&#34;../images/prototype12.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;welcome存在在新物件的prototype中，而且UserA可以使用這個method，酷吧 ! 同時我們也可以在物件之後再新增prototype方法，因為javascript egine是會沿著prototype chain去尋找的。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function User(name, friends) {

	this.name = name;
	this.friends = friends;
	this.greet = function() {
		console.log(&#39;Welcome&#39; + this.name);
	}

}

User.prototype.welcome = function() {
	return &#39;Hi&#39; + &#39; &#39; + this.name;
}

var userA = new User(&#39;Bob&#39;, [&#39;Ben&#39;, &#39;Andy&#39;]);


console.log(userA.__proto__);
console.log(userA.welcome()); //Hi Bob

User.prototype.sayYo = function () {
	return &#39;Yo&#39; + &#39; &#39; + this.name;
}
console.log(userA.sayYo()); //Yo Bob
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;試著想想這個背後強大的力量，今天我們用User建立了了千千萬萬個新物件，如果你想新增一個feature給所有的新物件，居然只要透過prototype property便可以一次新增給所有的新物件，這不是太神了嗎?這代表著你不用在來回複製個三天三夜，不用需要複製到血流成河阿 !&lt;/p&gt;

&lt;h3 id=&#34;why-prototype&#34;&gt;Why prototype&lt;/h3&gt;

&lt;p&gt;通常比較好的javascript code你會發現，function constructor通常只包含著單純的property，而method通常都會放在prototype裡面。這是為什麼? 為什麼不把welcome放在constructor裡面，這樣每次新建的物件就會有這項method了阿 ?&lt;/p&gt;

&lt;p&gt;年輕人就是太天真，想當初我也是這樣覺得沒事搞個prototype來幹嘛，直接在constructor解決就好，神經病沒事找事做。但你仔細想想，new 這傢伙是幹嘛的? 創造一個新物件? funciton也是什麼 ? 一個物件? 有沒有注意到一點點事情 ?&lt;/p&gt;

&lt;p&gt;沒有錯 ! 每一個物件都佔了一個記憶體空間，倘若method都塞在constructor 這代表著雖然每一個物件都有此方法，但每一個物件也就多佔了一次這個method的記憶體空間。&lt;/p&gt;

&lt;p&gt;也就是如果我們把welcome寫在User裡面，新建了一百個物件的話，就多佔用了100個welcome method的記憶體空間&lt;/p&gt;

&lt;p&gt;那如果是prototype呢? 它是把物件的prototype refer到 constructor prototype的property，也就是所有物件的method都是指到同一個地方，同一個method。&lt;/p&gt;

&lt;p&gt;有沒有一種恍然大悟的感覺，100 : 1的差異就在這裡啊，這也是為什麼會盡量把method放到prototype裡面，可以大大節省空間阿。&lt;/p&gt;

&lt;h2 id=&#34;look-at-the-big-picutre&#34;&gt;Look at the big picutre&lt;/h2&gt;

&lt;p&gt;上面我們明白了constructor 跟 prototype的好處，試著多想一點，平常我們常見的String、Array、Number等等，是不是都有自己的method呢 ? 沒有錯，他們都是Javascript內已經有建好的constructor，並在prototype property中建好我們常用的method。&lt;/p&gt;

&lt;p&gt;&lt;img style=&#34;width:100%;height:auto;padding:10px&#34; src=&#34;../images/prototype14.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;有了此概念之後，你便可以利用這個觀念，去延伸出自己想要的功能，這也就是其他人如何寫出自己的library。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;String.prototype.isLengthGreaterThan = function(limit) {
	return this.length &amp;gt; limit&#39;
}

console.log(&amp;quot;John&amp;quot;.isLengthGreaterThan(3)); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的範例就是透過今天的觀念，在String裡面新增一個method方便自己使用 ! 但這樣的行為是非常危險的，盡量避免修改到 built-in constructor，除非真的對其中的設計觀念非常清楚，不然真的隨時會陣亡阿，上面是個不良示範，大家不要亂來。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;以上就是今天的內容拉，掰鋪。&lt;/p&gt;

&lt;h3 id=&#34;參考來源&#34;&gt;參考來源&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.udemy.com/understand-javascript/learn/v4/overview&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;Udemy Course - JavaScript: Understanding the Weird Parts&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech Note on Ben the front-end dust</title>
    <link>https://WenXuanLee.github.io/categories/tech-note/</link>
    <description>Recent content in Tech Note on Ben the front-end dust</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language>
    <lastBuildDate>Wed, 09 Jan 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://WenXuanLee.github.io/categories/tech-note/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Socket Programming</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/tcpandudp/</link>
      <pubDate>Wed, 09 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/tcpandudp/</guid>
      <description>Socket Programming: Creating Network Applications 複習一下當我們建立一個network application，我們基本上包含了一組programs，client program &amp;amp; server program，分別存在於兩個end system，當兩個program執行後，client process &amp;amp; server process被建立，這些processes透過socket互相溝通，因此身為一個developer主要就是負責撰寫code for clicent program &amp;amp; server program
Network applications有兩種types，一種為implementation，主要實作於protocol standard，例如 RFC 或者其他 standard document，這樣的application通常又被稱為open，因為規則以及行為是被公開，因此此類別的程式設計需要遵守standard的標準。
另一種type則為proprietary，此類型主要運用的protocol尚未被公開發布在RFC或者其他國際網路規範，client side &amp;amp; server side program都由同組開發者完成，而開發者完全掌控code的內容，由於此類別並非實作於公開的protocol上，其他獨立開發者也就不能開發與此application相互操作的code。
下面會透過簡單實作的code來探討開發一個client-server application的簡易流程，在開發者階段，第一步主要得決定此application是基於 TCP || UDP，因此會就此兩種protocol類型來介紹。
Socket Programming with UDP sending process將packet push 到 socket 前，UDP會先將destination address資訊帶給packet，packet到達sending socket時，Internet便會根據此資訊導引到receiving process socket。由於傳遞的途中或許會經過許多network application process以及多個sockets，辨別destination receiver socket是必要的，因此在socket建立過程中，port number會被指認到socket當作idtentifier。而此項訊息也會被包含在destination address裡。此外，source address的資訊有同樣會被帶入packet，特別注意到，source address的帶入動作並非由UDP application code執行，而是自動由operating system完成的。
Socket Programming with TCP 不同於UDP，在client &amp;amp; server 開始彼此溝通前，必須先通過handshake的行為並建立TCP conntection，TCP connection的兩端分別連結著sending socket &amp;amp; receiver socket，建立的同時也會將兩端的IP address 以及 port number連結於TCP connection上，兩端的互動都將由socket把data丟到TCP connection傳遞。不同於UDP的server必須先將destination address 附在 packet上才能進入socket傳遞。</description>
    </item>
    
    <item>
      <title>Peer-to-Peer Applications</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/p2p/</link>
      <pubDate>Tue, 08 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/p2p/</guid>
      <description>Peer-to-Peer Applications 探討適合用於P2P設計的application，主要分於兩部分，第一部分為file distribution，介紹檔案如何從單一來源分配至多數的peers，這部分清楚的展示了P2P架構的 self-scalability，主要透過BitTorrent system為範例。第二部分則會探討 database distributed over a large community of peers。
P2P File Distribution 每個peer都可以提供自己的capacity來幫助server distribute 檔案，不同於client-server的模式，在分配檔案時，server不需要copy每一份檔案給peers，反之，只要其中一個peer擁有檔案之後便可以透過此peer重新再分配檔案到其他peers。放一張比較圖
BitTorrent Torrent在此的定義為，所有參與同一檔案distribution的peers的集合，每個於此Torrent的peer都會下載同樣容量的chunks，通常為256KBytes為一個chunk，當peer首次加入torrent並無任何chunk，隨著時間他會存入越來越多chunk，下載的同時也成為upload的來源之一，但檔案完成後可以選擇繼續留著torrent當為upload source之一繼續提供流量或者就離開torrent。
每一個torrent會擁有基本的node called tracker，當peer加入torrent時，會把自己註冊進tracker裡面並固定一小段時間通知tracker我還在torrent裡面。當一個新的peer加入時，tracker會隨機挑出一個peers子集合以及這群子集合的IP address丟給新的peer，擁有這些資訊後，新的peer便能與這群子集合建立TCP connection，通常這樣的子集合群稱為neighboring peers，建立TCP連結後便能從這群peers裡面獲取需要的chunks。
rarest first 決定取得chunck採用的技術之一，會從使用者當前沒有的chunks裡面去判斷，這些尚未擁有的chunck哪些是在neiboring peers重複性最低的，優先抓取此chunk。目標在於讓此rarest chunk更快的能在torrent裡面擁有與其他chunks一樣多的copies。
在BitTorrent協定中，主要根據peers內擁有最高的傳輸速率作為respond的判斷依據，也就是說，每十秒使用者會偵測接受到的rate以及upload rate，這個符合最高速率的set稱為unchoked，而每三十秒會隨機抓取一個額外的neighboring peer傳送chunck，此額外的peer稱為optimistically unchoked，若此peer正好速率高過於unchoked的其中一個，則此會替代成為unchoked之一，相對來說，若互相都滿足彼此的highest rate，則互為unchoked之一。
其他neighboring peer則稱為choked也就是不再top four peers(unchoked) and one probing peer(optimistically unchoked裡面，choked並不會接受從使用者接收到chunks。
Distributed Hash Tables(DHTs) P2P系統裡，每一個peer會存取一小部分的key-value pairs，每一個peer都可以發出query到distributed database獲取對應的value，收到query後database作抓取擁有此key值value的peer並回傳給發出query之peer，任何一個peer都准許插入新的 key-value paris到database裡面，這樣的設計稱為 distributed hash table
 Reference  Computer Network  </description>
    </item>
    
    <item>
      <title>The Internet&#39;s Directory Service</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/dns/</link>
      <pubDate>Mon, 07 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/dns/</guid>
      <description>DNS The Internet&amp;rsquo;s Directory Service 網路上主要辨識host的方法為hostname &amp;amp; IP address，IP主要由4 bytes以及有自己的嚴格規則形式組成，使用者習慣使用網址來記host，而router則是偏好固定規則的IP address，為了整合這兩種特性，於是有了DNS (domain name system)。
DNS是IP address &amp;amp; hostname對映的分散式資料庫，應用層的協定允許hosts對此資料庫發送query，DNS協定主要以UDP為底使用port 53。之前提過的HTTP SMTP FTP也都有使用此協定，用於將此用者提供的hostname轉化成對應的IP。
所以當我們輸入網址，發送request時，會先觸發DNS application，browser從URL抓取host name並傳給DNS application，接著DNS clicent 傳送包含此hostname的query給DNS server，獲得對映的IP address，再回傳給browser，一旦browser獲取到IP後便開始建立TCP通道。而注意到通常IP網址會被快取在 nearby的DNS server內
Overview of How DNS Works DNS是如何從DNS Server 找到對應的IP ADDRESS呢，如上述我們提到的DNS server，實際上的架構是有階級制的架構，由上而下為Root server -&amp;gt; TLD(top-level domain) server -&amp;gt; authoritative DNS servers，假使今天看到amazon.com的網址，DNS會從root開始聯繫，root 回傳對應到的 IP address以及TLD server，接著再從TLD server回傳對應到的IP address及 authoritative DNS server，最後回傳準確的IP address。
值得注意的是，DNS帶有Cacheing的Feature，也就是每當 DNS Server 收到reply message時，是可以cache message裡面的資訊在local memory裡面，當下次再有類似的host name query時，便能從cache住的資訊回傳，即便此DNS server 不是 authoritative for the hostname的，由於 IP address &amp;amp; hostname的關係並不是永久的，通常cache的資訊兩天後就會被拋棄。</description>
    </item>
    
    <item>
      <title>Overview FTP &amp; SMTP</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/mailandfile/</link>
      <pubDate>Tue, 25 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/mailandfile/</guid>
      <description>File Transfer FTP user 主要透過 FTP user agent與FTP互動，為了辨認User，User會提供User identification and password給FTP辨認用，FTP同HTTP是以TCP protocol為基本運作，但不一樣的是，FTP使用了Two parallel TCP connections來傳遞檔案，control connection &amp;amp; data connection，前者主要用來傳遞hosts 的 control information &amp;amp; commands to put and get files，後者則為實際真的傳送檔案，特別注意到data connection是non-persisent。
FTP server是必須維持user state的，也就是server會觀察user在要求檔案或者抓取檔案時的行為，FTP同樣會回傳Response，帶有基本訊息包含成功或者失敗訊息等等
Electronic Mail in the Internet 三個最主要的核心為，user agents、mail servers、SMTP，一封電郵的旅途會是這樣的，假使今天A寄了一封信到B，A透過user agent，也就是g-mail、apple mail&amp;hellip;，讓使用者可以傳送回復編輯信件等等，完成後user agent會將信件送到user mail servers，接著從user mail server傳送到receiver mail server，接著B的user agent再從receiver mail server去抓取信件到B信箱裡面。
mail server提供了信件的基礎功能，包括若A的信件無法成功傳遞到B的mail server，則此封信件會排到message queue裡面，待三十分鐘(常見的頻率)後重試，若多天重試後仍無法成功則移除此message並由mail server發送通知給sender，mail server同時也記錄了憑證確認Sender &amp;amp; receiver。
SMTP protocol主要為email的協定，套用了reliable data transfer service of TCP保證信件的傳遞，SMTP也擁有client &amp;amp; server side，前者主要作用於sender mail server，後者則為receive mail sender，廣義的定義而言，mail server 傳送信件到其他 mail server 視為 client side，負責接收的 mail server 則為 server side</description>
    </item>
    
    <item>
      <title>Web Caching</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/webcaching/</link>
      <pubDate>Wed, 05 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/webcaching/</guid>
      <description>Web Caching Web Cache，aka proxy server，network用於代替Origin Web server滿足HTTP request的機制，web cache擁有自己的storage空間，並會把最近收到請求的objects存在storage，user browser可以透過config讓所有的request都先被轉到web cache裡。
假使今天client端發送出一個request，一樣會建立一條TCP connection至web cache，接著web cache檢查是否有一份備分的object在儲存空間裡，若有的話，web cache直接代替server送回response，若無的話則送出request建立TCP connection至 origin server，取得response後在自己的storage 備份object，接著再送回clicent side。
web cache 同時是client &amp;amp; server，web cache主要應用有兩個原因，一者為減少response time for client request尤其當client to server 的頻寬小於 client to web cache時候，二者為減少traffic，若request並無真的發至origin server 可以減輕server的負擔並減少access to internet的traffic，因此可以對此設計提升效能。
The Conditional GET 上述提到Web cache的好處，但也有一個隱憂是，假使 origin server的檔案在web cache儲存後有所更動的話，該怎麼處理，HTTP提供一個機制讓web cache可以去確認 object是否為up to date，這機制稱為Condition GET，符合conditional GET的條件為
 request message 用的method 為GET request message header line 夾帶 IF-modified-since  記得在response message有著一筆Last-Modified的紀錄，而當web cache再次收到request時，web cache會觸發up-to-date check 發出一筆condition GET夾帶If-modified-since，若web server判斷無modified的話，則會回傳response without requested object，並在status line帶著status code 304 not modified</description>
    </item>
    
    <item>
      <title>Overview HTTP</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/httpoverview/</link>
      <pubDate>Tue, 04 Dec 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/httpoverview/</guid>
      <description>Overview of HTTP HyperText Transfer Protocol(HTTP)，application-layer protocol，被定義在RFC中，在client program &amp;amp; ser ver program中被實行，在不同的end systems中執行，在兩端透過交換HTTP messages進行交流。
Web page(documents)由不同物件組成，這裡的物件指的是FILE，例如HTML、JPEG、JS檔案等，而這個PAGE可以透過URL找到存在位址。URL則由hostname、object&#39;s pathname組成。以http://www.someSchool.edu/someDepartment/picture.gif 舉例，/www.someSchool.edu就是 hostname，someDepartment/picture.gif則是檔案的pathname。
HTTP定義了 web client &amp;amp; web server中間的溝通，包括client如何送出message以及server如何轉送webpage給client，此外，HTTP使用TCP作為underlying transport protocol，因此當client端送出一個HTTP request message時會透過socket傳送給tcp connection，也從trp connection經過socket接回到response message，同理於server端亦是，而一旦message到socket interface後，訊息的傳遞的掌控就不再client端的手裡而是在tcp protocol下了。
值得注意的是HTTP是被稱為stateless protocol也就是每次的交流並不會留下痕跡，也因此，就算client端短時間發送一樣的request，對於server端來說，並不會因為剛response完前一筆request就不處理同樣的下一筆，反之仍視為另一筆request回應，儘管內容完全相同。
Non-Persistent and Persistent Connections 開發者可以決定當送出request/response pair時，是透過separet TCP connections 或者是 同一個TCP connection實行，若為前者則稱為Non-Persistent後者則為Persistent。
Non-Persistent 假使今天有一個html file裡面有十張圖片，整個重request到呈現頁面的步驟如下，
 HTTP clicent processs 啟動一條TCP connection到Server端，建立TCP connection client 透過 socket開始傳送message到server端 server端透過socket接收到request message，並在透過socket回傳封裝好的response message HTTP server process 告訴TCP connection 關閉此連結(但實際上並還沒關閉，直到確認clicent端已經接收到正確response後才停止) client端接受到response，TCP connection關閉，開始檢驗回傳的HTML檔案並找到圖片的references 取得十張照片，重複1 ~ 4的步驟十次  在這個過程中，取得web page的階段，建立了11條TCP connection，每條connection負責處理一對request/response</description>
    </item>
    
    <item>
      <title>Transport Services</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/transportservice/</link>
      <pubDate>Fri, 30 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/transportservice/</guid>
      <description>Transport Services Available to Applications transport service 這邊主要區分了四個面向的service大類，Reliable Data transfer、throughput、timing、security。
 Reliable data transfer - 假使protocol提供受保證的data delivery service則為受信賴的，亦即就是此service保證了一旦data從sending process傳遞到socket時就已經保證此data一定會抵達receiving process而且無任何error，若無提供此服務，則data從sending process之後有可能永遠到達不了receiving process端，這行為能被 loss-tolerant applications接受 throughput - transport提供了保證穩定傳輸速率的service，可以保證application能擁有的傳輸速度，Applications需要throughput requirements的類型又被稱為bandwidth-sensitive applications。 timing - 提供了時間的保證，可以保證資料傳遞的時間間距，此service相對real-time application是重要的。 security - 提供資料安全性的service，提供加密以及解密data的服務  Transport Services Provided by the Internet Internet(大部分為TCP/IP networks)提供了兩個協定TCP、UDP，當設計一個network application時的必做選擇之一為在此兩種協定中擇一，不同的協定提供了不同的服務，不同的應用程式也有不同的需求。
TCP TCP model 包含了連結取向的設計服務以及提供了reliable data transfer服務，TCP在client server端都擁有transpoart-layer control information在實際進入應用層面的message時啟動，也就是所謂的handshaking procedure，在握手階段完成後TCP connection存在於sockets of the two process之間。
TCP 以及 UDP 兩者皆沒有提供任何加密手段，但以TCP而言，廣大社群開發了一套SSL，用於加強於TCP中的安全考量，但注意到SSL並不屬於一種協定，跟TCP、UDP是不同的level，而只是TCP的強化，將加密手段實作於application layer
TCP的設計中包含了防堵塞機制，會在網路壅塞時，去控制process的送出以避免packet loss的問題等等。
UDP 相對於tcp，UDP相對寬鬆並只提供最小限度的服務，沒有加密手段，沒有防堵塞機制，也沒有任何Connection過程，甚至也不保證資料的傳遞，</description>
    </item>
    
    <item>
      <title>Network Application Architectures</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/networkapplicationarchitectures/</link>
      <pubDate>Wed, 28 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter2-application-layer/networkapplicationarchitectures/</guid>
      <description>Network Application Architectures network architecture，一個開發者設計一個application時，如何被架構在各個end system，而現今常見的net work application主要應用的兩個主流設計為client-server architecture以及peer-to-peer architecture (P2P)
client-server architecture 最終端永遠會存在於一台或以上的host，所謂的server，負責處理從其他end system傳來的service request，也就是所謂的client，最明顯的特徵是，clients之間並不能直接溝通傳遞訊息，必須得經由最上游的host來運作，另一個特點是server存在固定的IP Address，地址永遠是固定的而且server持續維持運作的狀態下，client便可以透過這樣的服務傳遞封包。
通常如常見的大型社群網站，會擁有data center，安放大量的hosts來做為一個強大的server，處理大量的用戶request，而因此也必須額外付出從data center到各個host的連線以及頻寬成本。
peer-to-peer architecture (P2P) P2P並沒有絕對依賴指定的host，不同於前者，clients在一組相互連結的hosts中可以直接與彼此溝通，稱為peers，peers並不屬於service provider而是各個users hosts，也就是不用轉折點的server去執行。
很明顯一項特點就是self-scalability，雖然每一個peers在request時都會產生workload，但同時也提升了service capacity，也就是說，每當一個peer加入時，整個P2P架構的系統，就會多增加一個peer提供的資源、頻寬以及計算能力，但同時越多使用者的話，傳輸的效率也會越慢，此外，由於不需通過指定server的運作，也省去了從host -&amp;gt; server的頻寬以及服務功能。
方便的同時也須注意三個隱憂
  ISP Friendly - 大部分的地區ISPs已經切割好指定的頻寬使用，為了準備應付更多的downstream than upstream traffic，而P2P的設計則會把佔頻寬的upstream traffic從server搬移至ISPs運作，造成ISPs更大的負擔，因此在設計上得納入考量。
  Security - 顯而易見的彼此users都是open的，所以也很容易遭受到惡意攻擊。
  Incentives - 以P2P的設計來說，得吸引使用者去提供自己的頻寬、儲存空間以及資源。   Process Communicating process可以想像成，一隻program在end system上執行，Processes在兩台不同的end systems上主要透過messages的交換來溝通。
Client and Server Process Network application 都會有一組processes組成，透過network傳送messages給彼此，通常會將兩個processes一個定義為clicent另一個為server，以常見的google為例，我們的browser就是一個client process發送request message給server process接收並給予回應，在P2P的設計上來說，peer可以同時為client與server，有一個定義是指觸發訊息交換的process為client，而等待被聯絡的process則為server
The Interface Between the Process and the Computer Network 所有message從process出發到接收一定會經過network，而透過將process message傳遞到network的介面就是socket，也被稱為API。可以記為socket為application layer &amp;amp; transpoart layer的interface，通常開發者會在application-layer side of the socket 擁有比較多的控制權，反之在transport-layer side便沒有太大的操作空間。</description>
    </item>
    
    <item>
      <title>Network Attack</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/networkattack/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/networkattack/</guid>
      <description>Networks under attack malware 惡意軟體 透過Internet的傳遞，我們的機器很可能被有意地傳送惡意軟體，例如以前常見的email釣魚信件，一旦我們的本機成為了受侵入的compromised host，就也有極大可能被hackers拿來當作botnet，繼續散步惡意軟體。
多數的惡意軟體都是能自我增值的，也就是一旦有一台主機被侵入，惡意軟體就可以根據被侵入的主機繼續尋找可以侵入下一台主機的機會，也因此惡意軟體一旦散布出去後，是成指數成長的。常見的惡意軟體主要分為兩種type
Virus - 必須透過使用者的互動才會受到侵入，例如釣魚信件裡的附件，開啟附件後才會被侵入。 Worm - 不必使用者互動就有可能受到侵入，例如在不安全的網站下，就有可能遭受到攻擊。
Dos attacks (denial-of-service) Dos attack攻擊network的服務，讓合法使用者無法正常使用network service。
Vulnerability attack - 在netowrk過程中塞入惡意message，當packet順序偶然按照惡意訊息的順序接受到，就會受到惡意攻擊。 Bandwidth flooding - 送出海量的垃圾封包，讓目標host的packet堵塞，讓其訊息無法送達server Connection flooding - 在target host建立大量開放式或半開放式的TCP connections，讓封包進入這些意的connection之後就中斷了
DDoS - 則是應用第二種攻擊方式，由單一source傳送大量垃圾封包是容易被發現並被阻擋的，而DDoS則是透過一台source將海量封包分配到botnet下再由這群botnet送至destination，造成堵測的問題
Sniff 在現代網路access方便的年代，例如Wifi，同時也隱藏的網路安全危機，由於只要在附近的的人都可以連取到，同一個發收器訊號，也意味著，當訊息傳遞時，附近所有的人同時也是passive receiver有權去記錄copy of packet，若包含重要的隱私訊息也同樣會被複製下來，而較常見的解法變是加密，待packet到目的地時在解密。由於這種手法是被動接受的，相對難以偵測。
masquerade 透過自己製作一個封包並帶著false ip address，送入internet裡面傳遞，在route的接受過程中，是有可能把人工的packet認為是可信任的封包，並繼續接下來的SOP。而這也能達成偽裝成其他使用者的目的，通常這種把帶有假IP address的packet注入到Internet裡面稱之為IP spoofing，是偽裝方式中常見的的一種方式。
要防範此種行為，便是在end-point加上驗證的階段，有了驗證的機制去確認此封包到底是不是我們所認為的封包。
 Reference  Computer Network  </description>
    </item>
    
    <item>
      <title>Network Layer</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/networklayerbrief/</link>
      <pubDate>Tue, 13 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/networklayerbrief/</guid>
      <description>Brief-intro about Five Layers 層級的概念是，個別層級中有自己的服務，個別執行特定的動作已達成目標，而傳遞下去的層級中，是依賴於上一層的服務，舉例來說的話，買票之後才能上火車，第一層的服務為窗口買票，第二層為上車的動作，若第一層沒買票的話，則第二層便無法實現。
從上到下的五層順序分別為 Application Layer、Transport Layer、Network Layer、Link、Physical
Application Layer 應用層是最接近web app的，此層的協定包含常見 Http - 提供向瀏覽器發出request &amp;amp; transfer SMTP - 提供transferemail訊息 FTP - 提供檔案的傳輸協定 DNS - 提供轉換網址到network address
應用層協定分布於各個end system上，各個end system透過傳輸層提供的protocol去交換packet。
Transport Layer 主要將應用層傳遞下來的封包，透過TCP/UDP協定傳送，在此處也會在packet上加上header information，包含了允許封包在receiver那邊可以往上丟回application layer，以及errr-detection bits讓receiver知道message是否在route理被動過手腳
TCP - 提供messages的傳送以及flow control，也提供將packet切成segment，以及packet塞車的處理機制 UDP - 提供了當無網路狀態時web app的service
Network Layer 負責整個封包傳遞流程的datagrams，主要為IP protocol，定義了datagrams的區域以及end system &amp;amp; router如何在這些fields做行為，特別注意到IP protocol只有唯一一個，所有Internet component一定都得遵守，同時此層也包含許多routing protocols。
Link Layer 將packet從node中運輸依賴的是link layer的服務，負責傳送network層的datagram到下一個node節點。此服務依賴於link-layer protocol，常見的link-layer protocol為以下Ethernet Wifi DOCSIS等等，同一組datagram可能會在不同的Route被不同的協定服務，通常在link-layer的packet又稱為frames
physical Layer 就幾乎是實體線路的範圍了，在此不做贅述
Encapsulation 封包在傳遞的過程中，所經過的layer並不相同，如下圖所示，在link-layer switch以及router裡面，packet作用的service在後面三層，而在end system才有到頭兩層，在層數往下的過程中，都會加入header information作為保護的手段，如圖中的Ht、Hn，因此我們可以依圖所例，得知每個層級都會有兩個type of fields，一者為前一層帶下來的packet，一者為每層級的header information。</description>
    </item>
    
    <item>
      <title>Packet Probrlm</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/packetproblm/</link>
      <pubDate>Thu, 08 Nov 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/packetproblm/</guid>
      <description>Delay, Loss, Throughtput Types of Dealy 假使今天sourceA丟出一個封包道destinationB，途中可能會經過routerA、routerB，當packet運送到routerA時，routerA會有一條outbound link到routerB，進到此link前會有一個queue，判斷當前是否有其他packet，是否正在此link傳輸資訊。所以今天new packet送到routerA時，routerA會根據header資訊決定將new packet安排到特定link，當link有數據正在傳輸時，new packet便會進到queue裡面去等待。
Processing Delay 解讀packet header並解決定此packetmap到特定link的時間就是process delay，通常在routers裡面，此種delay的時間大概落於microseconds or less
Queuing Delay 就字面上的意思，當packet 進到queue裡面，等待其他先到達的packet完成傳輸的時間成本就是Queuing Delay，通常此delay的時間實務上落於microseconds to milliseconds。
Transmission Delay packet傳輸到link的所耗費時間，假使今天packet有L bits，link的 transmission rate R bits/sec，那麼transmission delay的時間便是 L/R，此delay的時間實務上落於microseconds to milliseconds。
與propagation delay區別的話，transmission delay為packet中的每個bit從link到router裡面組好完成一個packet後的等待時間，假使今天有一個packet中包含十個bit，十個bit分別排隊等待進入router，而第一個bit通過router後仍然得在router裡面等待另外九個bit來後組成一個packet才能往下一個router前進，十個bit調router的時間就是transmission delay。
Propagation Delay 從link將資料傳遞到router的時間成本，Propagation speed主要影響為實體的線路，指的是一個packet從router到router的時間，而影響此數據的實際因素為router間的distance。
Traffic intensity Traffic intensity 代表的是每秒傳送到queue的密集度，假設今天有X個packets，每個packets皆由Y bits組成，而若transmission rate為Z bits/sec，則密集度為XY/Z
此密集度通常用來評估queueing dealy的長度，若Traffic intensity &amp;gt; 1也就是每次進來排隊的packet大於送出去的packet，那麼queue就會無限長，因此最最最基本的設計為，Design your system so that the traffic intensity is no greater than 1</description>
    </item>
    
    <item>
      <title>Switching</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/switching/</link>
      <pubDate>Thu, 25 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/switching/</guid>
      <description>Packet switching vs Circuit Switching 主要差別在於，前者並不會保留特定path，而後者會保留一個特定path給package。因此當packet switching同時遇到太多package進來時，就得進入到buffer裡面去排隊，等待安排output communication，Circuit Switching則不必等待，而是在進來之前已經先預訂好path，而因此，也必須在兩個end system裡面先建立好connection之後才能進行資料傳輸動作，而相對也有比較穩定的傳輸速率。
範例來說，如果今天有N個使用者的話，套用circuit switching的方法可能最高只能容納10個使用者同時運作，因為會預先保留頻寬給user，當user可能還沒進行傳輸時，就會一直保留住，導致於後面進來的user，得一直卡在buffer裡面，有種占著茅坑不拉屎的感覺。
packet switching則不會保留頻寬，只要有空位使用者便進來使用而且傳輸，今天若同時有十個人進到餐廳裡面，但有五個人還沒開始用餐的話，packet switching則會先把五個座位安排給可以馬上用餐的人，所以相對circuit switching來說，就不會有被佔住位置的問題。當然如果五個user都佔據超大數據傳輸資料的話，仍然會有buffer塞爆的問題了
TDM &amp;amp; FDM TDM是將一個connection的duration切成frame，每個frame中在切出time slot，User開始傳遞資訊時便會被塞到time slot，也就是在一個固定的時間內切割頻寬，同時允許多個使用者傳遞資料，time slot越多，相對地速率也會趨緩。
FDM則是依頻率來切割link區段，而使用者同時在同一個切割區域裡面做傳輸，不同於TDM是一個一個將使用者塞到slot裡面去做動作，FDM是一起將user丟到一個pool的感覺。
networks of networks  Reference  Computer Network  </description>
    </item>
    
    <item>
      <title>Protocol</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetpacket/</link>
      <pubDate>Tue, 02 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetpacket/</guid>
      <description>Protocol 協定的存在就像是人類的語言，不同的語言交流一定會有障礙，若不是大家遵守同一套協定，說著不同的語言，那是無法溝通的，所以Protocol的存在就是讓兩台機器有一個交流的共識，如此才能辨識送過來的請求以及回送相對應的回覆，已完成我們想要達成的目的，例如從clint side 打API 從server side得到相對應的資料，中間的請求與回覆就得有一個協定存在。
Network Protocols 網路協定的動作是由software or hardware執行，也就是我們的電腦、手機、路由器等等，所有在Internet上的包含兩個或以上遠端機器的行為都會由協定來管理監控，以一個例子來說，當我們對Web server發出請求時，也就是輸入一個URL到Browser時，我們會先從自己的電腦發送一個request至Web server，Web server接收到請求時會根據request message去給出一個回應replay message，接著我們的電腦收到OK的reply後，已GET message 丟出我們輸入的URL撈取相對應的document，接著Web server回傳我們要的Web page回到computer顯現。
protocol定義了整個溝通流程的SOP，包含初始步驟是傳遞request以及收到reply，採取什麼動作或者針對不同事件做出不同回應等，不同的protocol在不同的情境使用以達成不同的communication tasks。
Access Network Home access: DSL, Cable, FTTH, Dial-Up, and Satellite 目前一般家庭最常見連結網路的方式為透過DSL &amp;amp; Cable，DSL就等同於透過電信公司提供連結管道，包含了電話與網路的ISPs，也就是中華電信那台數據機，有點像是電信公司透過電話線切割兩條線路出來，一條給家用電話，另一條就是給DSL數據機提供上網，所以大家可以理解到十年前每次有電話來就會斷網路的情況就是電話線路的切割部分沒處理好。
所以大概的架構就是家用的電話訊號以及網路訊號會傳送回電信公司也就是DSLAM去送回Internet以及Telephone network
Network Core Store-andForward Transmission packet switch在接收到整個完整data拆散後的封包才開始傳送first bit到外部link，也就是source -&amp;gt; router -&amp;gt; destination，source data如果切成了 packetA、packetB、packetC，在A到達之後仍會先被儲存到router(packet switch)待三個封包都到達之後才送往outputlink。
Queuing Delays and Packet Loss 通常每個packet switch 會有連結許多communication links，對於每個link，packet switch會有一個output buffer，當packet傳送中又有另外一個packet到達時，剛到達的packet則會被放入buffer中排隊，等待傳到link上，因此就會有queuing Delay的問題。
而packet loss則是因為buffer區域的空間有限，當塞爆的時候，可能是剛到達的packet被丟棄，或者是在queue等待的某個packet被丟棄。
Forwarding Tables and Routing Protocols packet switches 如同之前所講的，有許多連結的接收communication links &amp;amp; output links，那麼router是怎麼決定這些link的使用?</description>
    </item>
    
    <item>
      <title>Internet Basic</title>
      <link>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetbasic/</link>
      <pubDate>Wed, 19 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/networklayer/chapter1/internetbasic/</guid>
      <description>Internet Internet主要大概流向為 ISPs -&amp;gt; routers -&amp;gt; Moerdem -&amp;gt; routers -&amp;gt; end system, base station等等
packet為封包，透過目標host將傳輸的資料轉成片段的封包，並在header 加上bytes，類似於加密的功能，網路上的資訊都是透由packet傳遞。
communication links封包的接受與傳送主要透過此links連結，在packet switches裡面會從多個incoming communication links之一挑選一個接收封包，再由多個outgoing communication links傳送封包出去，兩者的運用就是主要封包的傳遞路程，最後送到欲到達的end sysystem裡面重新解密原始資料。
而整個從第一個end system丟出封包到另一台end system的過程稱為一個route || path
網路資訊的傳遞過程就像是貨物運送流程，packet就像是一台卡車，負責載著貨物(data)到目的地，communication links則是卡車行駛的道路或者高速公路，packet switches則像是中繼站或者十字路口，負責決定將封包分配到目的地，也就是end system並卸載，而整個配送過程就是一個route || path
當今最主要的packet switches方式為router &amp;amp; link-layer switches
 router 主要使用在network core裡面 link-layer switches 通常使用於access network上  TCP/IP 目前 Internet 最重要的兩個協定，IP主要是規範於封包在router &amp;amp; end system傳遞過程中的格式。
API指的是一組規則，傳送資料的program必須得遵守此規則，Internet才能准許傳送data到指定的目的地，以寄信來做個比喻的話，假設A要寄信給B，不可能只把信寫好，丟在門口，信就會自動到達位置的吧?
寄信的過程得必須遵守，將信放置信封袋，寫上收件人、收件地址、貼上郵票，丟到郵箱丟到郵筒後才會準確寄出，相同於API，program傳送資訊必須遵守一定的規範才能透過API傳送資料到另一台end system。
 Reference  Computer Network  </description>
    </item>
    
    <item>
      <title>prototype</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day25_prototype3/</link>
      <pubDate>Tue, 09 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day25_prototype3/</guid>
      <description>Constructors &amp;amp; prototype 前面我們提到了prototype的概念，也知道了物件裡的prototype chain是怎麼回事，我們回想一下創造物件的方式有哪些，除了一般的宣告，還有一個在function介紹的方式，也就是constructor，那透過constructor創立的物件如何去設定它的prototype呢?
今天我們就來探討一下這個問題
One for all &amp;amp; All or one function User(name, friends) { this.name = name; this.friends = friends; this.greet = function() { console.log(&#39;Welcome&#39; + this.name); } } var userA = new User(&#39;Bob&#39;, [&#39;Ben&#39;, &#39;Andy&#39;]); console.log(userA.__proto__); // {constructor User} 當我們透過function 建立物件時，在new的時候Javascript Engine就會自動幫我們建立好prototype chain，新建的物件會有一條prototype chain連結到constructor。
Special Property 回想一下，我們說過每一個物件都有自己的一個property叫做prototype吧，而所有函式之中也有一個特殊的property，這也是我們把函式當作constructor使用時應該要注意並好好運用的一個special property。
每個函式雖然都有prototype這個property，但除了function constructor，一般函式是不會用到這個property的。就只有 ! 當今天把函式用來建立新物件的時候，這個Property才會被使用到。
function User(name, friends) { this.name = name; this.friends = friends; this.greet = function() { console.</description>
    </item>
    
    <item>
      <title>Color Game</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day27_colorgame/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day27_colorgame/</guid>
      <description>Color Game 30天即將到了尾聲，雖然文章寫的七零八亂又超沒系統的，還是小小期盼大家有從中獲得一點什麼，而上面幾乎都只是文字介紹，很少動手code的部分，但學code就是要學中做、做中學，所以我們這兩天，就來小小寫一個遊戲吧。
這個遊戲是我看到有人分享清大線上課程時候，自學的時候的一個作業，我覺得挺有趣的，就分享給大家一起來寫寫看，以下是它的作業需求 Color Game
但由於我們介紹的部分是Javascript，我們就針對Javascript的部分一步一步來完成這個小專案，至於html &amp;amp; css的部分我們就直接套用git lab提供的，雖然script的部分上面也有了，但建議大家可以先自己寫看看，我會照著上面範例的script一步步解釋其中的code是怎麼回事，但如果大家能自己想出來那是最好的了。
那我們就開始吧 ! 我們準備寫script的地方是Code Pen，Code Pen是很方便的好所在，沒事無聊想寫寫小東西都可以在這邊操作，雖然我都是在本基端就是XD，大家可以去code pen fork我這個沒有script版本的code來操作。
Code Pen連結
Play with it 首先，看到這個我們觀察整個動作的流程是什麼樣。
你看到了什麼? 我們可以看到整個遊戲有許多跟Javascript有關的動作。
 可以點擊的難易度選擇。 點擊難易度之後遊戲畫面的變換。 每一張可以點擊的卡片。 卡片點擊後的變化。 卡片顏色的產生以及題目的產生。 判斷卡片顏色是否正確以及遊戲是否結束。 是否重新開始遊戲。  簡單來說大概是這樣，所以我們開始建立script前，強烈建議大家先想好到底有哪些功能需要注意，不要一股腦的還沒想好架構就暴走一波。
Start coding 有了大概的結構我們可以開始思考我們的Code要怎麼寫了，這邊是按照我個人的習慣，由於我不太有耐心，喜歡先把簡單的部分做掉，先得到一點成就感不然很容易喪失鬥志，所以我第一個動作為以下。
先處理好所有需要有點擊動作的傢伙。
window.onload= function() { initMode(); initCards(); }; var mode = &#39;hard&#39;; //初始遊戲難度 var resetButton = document.querySelector(&amp;quot;#reset&amp;quot;); //抓到reset button var modeButtons = document.querySelectorAll(&amp;quot;.mode&amp;quot;); //array 儲存所有class為mode的tag var cards = document.querySelectorAll(&amp;quot;.card&amp;quot;); //array 儲存所有class為card的tag function initMode() { for(let i = 0; i &amp;lt; modeButtons.</description>
    </item>
    
    <item>
      <title>prototype</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day24_prototype2/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day24_prototype2/</guid>
      <description>Everything is Object 今天來談談prototype一些注意的細節，我們知道Javascript裡面所有的變數都是一個物件不然就是Primtive，也就是說除了primitive - number, string, boolean, ect 以外，全都是物件 - function、array、basic objects. 所有的物件以及primitive都有prototype。
但唯一有一個例外，base object，也就是object的最底層。
Everything has a prototype 讓我們用一下範例來看一下prototype吧，我們用basic object、function、array為例子。
var a = {}; function b() {}; var c = []; Object a 我們看到了物件a的proto仍然是一個物件，而其中擁有許多property以及method，其中我們可以看到熟悉的toString()。
function b function b的proto則是一個function object，而其中包含的許多method，包含我們先前才介紹的call()、apply()、bind()，這也就是為什麼每個function都能使用這三個method的原因，就是擁有這個function prototype。
array c array的proto我們看到了仍然是一個object，而這個object包含了常見的array method，包括了 pop()、push() &amp;hellip; ，所有的array proto都會指到這一個object，也就是為何每個array都可以用到常見的method。
Tricky 透過三個範例知道了為什麼平常可以用一些好用的method了嗎，這就是prototype的功力阿，
那如果這些proto的proto又是什麼呢。
這就是最底層的object了，每個object都共享的base object。
reflection &amp;amp; extend 接下來我們深入探討一下object的兩個觀念，有助於我們理解prototype的運作
Reflection Reflection的定義為，object可以查看自己，列出並更改自己的properties &amp;amp; methods。所以Javascript Object能夠觀察自己的properties &amp;amp; methods。
透過這樣的一個特性我們可以實行一個好用的pattern - extend。 那我們先來看一下 Reflection的範例。</description>
    </item>
    
    <item>
      <title>prototype</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day26_fp/</link>
      <pubDate>Mon, 08 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day26_fp/</guid>
      <description>Functional Programming 我們明白Javascript的函式是first class function，也就是function可以被當成value,parameter，甚至return 一個function，這樣的設計就讓我們可以延伸到一個程式設計的概念，funtional programming，前面有提到，但挺簡略的，今天就來了解這個程式設計概念吧。
Sample#1 先看個範例，感受一下functional programming的奧妙之處。
var arr1 = [1,2,3]; console.log(arr1); var arr2 = []; for(var i = 0; i &amp;lt; arr1.length; i++) { arr2.push(arr1[i] * 2); } console.log(arr2); 上面這個範例是不是顯得有點冗長，在程式中，我們通常想要越偷懶越好啊，打這麼多字豈不是浪費我的生命，打字的時間不如拿來打人中之龍。 接下來我們看functional programming的寫法。
function easyWay(arr, fn) { var newArr = []; for(var i = 0; i &amp;lt; arr.length; i++) { newArr.push( fn(arr[i]) //functional programming; ); } return newArr; } var arr1 = [1,2,3]; var arr2 = easyWay(arr1, function(item) { return item * 2; }); console.</description>
    </item>
    
    <item>
      <title>prototype</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day23_prototype/</link>
      <pubDate>Sun, 07 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day23_prototype/</guid>
      <description>prototype Prototype可以說是Javascript至關重要的一環，嚴格來說Prototype不管在哪個程式語言都是很重要的觀念，但Javascript的prototype觀念又跟多數的程式語言有著特別的不同。
今天就來討論一下最根本的觀念，Object-oriented Javascript &amp;amp; Prototypal Inheritance。
當提到了object-oriented，我們主要會專注在物件的創造，因為這個Part藏著許多讓人混淆的部分。
Inheritance 首先我們先理解繼承的概念，Javascript內的繼承核心概念就是，是一個物件可以access到另一個物件的property、method。
Classical Inheritance 如果你學過Java或者其他程式語言，相信你對class一定不陌生，透過class可以分享methods &amp;amp; properties給class的instance。
但聰明的你一定發現，這樣的繼承方式顯得有點冗贅，並且容易交互影響，很難去搞明白這群物件們是怎麼與彼此互動的，你得搞明白許多keywords protected、private、interface、blablabla。
並不是說classical的方式就是不好，它肯定有它的好處才會這麼受歡迎，只是仍然有些不足的部分。
Prototypal Inheritance Prototypal Inheritance，它相對的易於使用，並且容易修改或者擴增，以及容易理解其中的脈絡，但也不是完美無缺的，相對的結構比較鬆散，一不注意就會讓整個結構變的混亂。
Again 當我們提到Javascript的 inheritance時，我們就只在意一個最核心的觀念，也就是，一個Object 可以 access 另一個object 的 properties &amp;amp; methods.
想更清楚明白剛剛提到的兩種繼承差異，請服用下面這篇文章。
What’s the Difference Between Class &amp;amp; Prototypal Inheritance
Understanding the prototype 到底什麼是prototype呢，我們知道Javascript的物件都有properties，而實際上Javascript內的物件都有一個prototype property - proto ，
proto 主要是連結到其他物件的一個reference，而它也就是我們的prototype，看下圖。
今天我們obj.prop2若在原本的obj內找不到的話，則會往proto去尋找，也就是往prototype去找，借由proto再去看看有沒有一個property name，有的話則reutrn回來。
就片面來看我們會以為obj含有prop2，但實際上prop2是存在於object prototype裡面。
同時，proto這個物件可以再指到另一個proto，每個物件都有自己的prototype，可以一直延展下去，prototype的prototype可能也有其它property。
這樣一層一層prototype組織而成的鍊子，就稱為prototype chain - 原型鍊。
而這個原型鍊通常是藏住的不會被看到的，也就是我們不會打 obj.proto.proto.prop3，而只要obj.prop3就會得到，Javascript Engine會透過原型鍊去尋找property &amp;amp; method。
而不一樣的Object卻有可能擁有同樣的proto。
我們知道proto只是一個reference，所以我們share到的同樣的property，不論是 obj.prop2 or obj2.prop2指到的都是同樣的記憶體位置，同樣的property。</description>
    </item>
    
    <item>
      <title>call、apply、bind</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day22_callapply/</link>
      <pubDate>Sat, 06 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day22_callapply/</guid>
      <description>##call()、apply()、bind() 今天來介紹這三個function，多半這三個function都與昨天介紹的this有關，我們已經了解this可以指到global object 或者是包含method的其他物件，如果能控制this最後的會是什麼狀態是不是一個很方便又美好的事呢?
沒有錯，因此Javascript裡面提供了 call()、apply()、bind()，想要透徹瞭解這三個傢伙，我們首先得確保理解function的概念，我們複習一下。
我們知道function是一個特別型態的物件，它有 name property，也就是函式名稱也可以是匿名，以及code property，讓函式可以被呼叫的，記得函式是一個object，所以也可以擁有property以及method，所以今天提到三個觀念就是Javascript提供在function物件裡面的method。
##三幻神 vs this
###bind() 先看以下範例。
var friends ={ name: &#39;Ben&#39;, greet: function() { return this.name; } } var myFriends = function(argu1, argu2) { console.log(&#39;Hi&#39; + this.greet()); }.bind(friends) myFriends(); 透過昨天this的觀念，你一定了解了這個會造成error，因為函式myFriends的this會指到window，但加上了bind()後則可以正常運作。如以下
var friends ={ name: &#39;Ben&#39;, greet: function() { return this.name; } } var myFriends = function(argu1, argu2) { console.log(&#39;Hi&#39; + this.greet()); }.bind(friends) myFriends(); bind()的概念是這個method會return一個新的function，實際上就是將function做一個copy。
當Javascript Engine讀取到bind()時，在execution context 創建時，會將bind後的參數指到this去，所以這邊的this指的就會是friends物件。
###call() 利用call我們也可以達到一樣的效果，但有些不一樣的細節。
var friends ={ name: &#39;Ben&#39;, greet: function() { return this.</description>
    </item>
    
    <item>
      <title>This</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day21_this/</link>
      <pubDate>Fri, 05 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day21_this/</guid>
      <description>This 今天我們講講This，到底this是this什麼東西，榮登Javascript界Top3疑惑的傢伙，常常看到別人的程式碼this來this去的到底在搞什麼鬼，自己用的時候卻又不明所以，模模糊糊的，今天我們就來揭開這團迷霧吧 !
Throw back creation phase 當要探討this時，我們得先回想一下execution context，當execution context創建時，我們知道會有
 variable environment決定variable的建立以及存活 Outer reference environment確定位置，用來查詢scope chain的脈絡。 This - 我們的大魔王，每次創建時都會有這傢伙，我們不需要宣告或創建它，就是會給我們這個傢伙 this ，而它根據我們呼叫函式的方式，指向一個不同的物件。   也就是我們今天要探討的主題 !
Let&amp;rsquo;s get this !! This常常會帶來很多疑惑，因為根據函式呼叫的方式，每一次this指向的東西都會隨之變化，關於這個this會有許多情景，我們就來一探究竟。
this with window 我們已經知道，global execution context中也會內建一個this，而這個this指定到window。
讓我們換一個方式來看看，倘若今天用一個函式a包起來，並呼叫函式a。
函式裡的this仍然會指到window object。
我們再換一個方式，將function expression存放到變數中。
Again，還是指到window，不管是a或是b的execution context中，雖然各自取得自己的this，但取到的都是同一個記憶體位置的物件，也就是window，都指到了global object.
這代表我們可以做出一些特別的行為，如以下我們透過this.newVar建立了一個新的global object。 是不是挺莫名的，如果不明白this是如何指到其他物件，你會有錯誤的觀念以為this就是連結到函式裡面，燈愣 ! 那就完蛋拉，你便會不小心造出一堆global object進而有一堆問題。
this with object method 當今天我們object裡的method用到了this又會指到哪個物件去呢。
在這個案例，function是物件的一個method，屬於一個物件，當Javascript engine看到這個裡面的this，會認為，阿你就是連結到這個這個物件的，因此這個this指到物件C，因此我們可以做到下面這檔事。
看到了嗎，透過this.name我們改變了object的property，這是很方便一個用處，method中我們可以透過this拿到或改變其他同物件裡的properties，相當酷吧!
那如果今天method內又包含了一個function後會怎麼回事 燈愣 ! 你以為應該要秀出Big C 但事實卻不是這樣，那這個newName到底去哪了呢，讓我們來看看。 我的老天鵝阿，跑到了window的global object裡去了，這代表method裡面的那個function的this仍然指到了window，儘管它位於object裡面。
這不可能發生，直到現在，我還是不願意相信我的眼睛，相信你也跟我一樣，這太誇張了真的，但沒辦法Javascript大老就是這樣運作的，那我們遇到這種狀況該怎麼辦呢?如何確保我的this是指到我想要的object而不是window。
簡易的方法就是在確定this指到我們要的物件時，將它存取到一個變數中，之後透過這個變數去使用，如上圖的self。
當我們bind在一起 上面我們提到一個簡易的方法可以確保this所指向的物件，而其時Javascript也有一個方法叫bind()可以解決此類的問題，透過bind可以將this綁定在物件，而不要指到window去，後面會再介紹一次。</description>
    </item>
    
    <item>
      <title>Closures</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day19_closures/</link>
      <pubDate>Thu, 04 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day19_closures/</guid>
      <description>Closures Closures可以說是Javascript內的九陰真經，想真的精通Javascript，這是絕對、必須、不得不去完整明白的一個概念。而同時它也是惡名昭彰的難以理解，小魯我到現在至今是深受其擾，就讓我們一起再來重新認識吧 !
Closure Sample 首先，我們先看看一小段code，大概了解一下closure的厲害，接著我們會慢慢分析並了解其中的奧秘。
乍看之下好像一切都滿有道理的，但好像有哪裡怪怪的事情發生了，為了讓大家可以看清楚怪怪的事情，我們稍微更改一下範例。
仍然一樣的結果，就是這個Bug，但是!sayWelcome函式怎麼知道whatToSay是什麼?根據我們過去的理解，當greet函式執行完畢後，execution context會被清除，也就是whatToSay應該已經不存在了才是，但在sayWelcome中卻仍然知道原本的值。
這個神祕的力量就是closure，讓我們再看看exeuction stack了解其中的奧秘。
 程式碼執行到greet assign給sayWelcome，呼叫greet()並創建execution stack，當結束時回傳一個function expression。   程式執行完畢，return回來後，execution context pop out  問題來了，我們知道每一個execution context在記憶體中有一個空間，讓其中的變數以及函式可以是有效存活的，上面範例中，這個空間發生了什麼事?
正常而言Javascript egine會啟動一個garbage collection的機制，在execution pop out後清空這個空間，但在範例中這個空間卻依然存在，仍然在記憶體中的某一處。
接著程式繼續回到glbaol execution，
當程式繼續執行進到匿名函式時，Javascript Engine看到whatToSay時，會怎麼做?我們知道有了Scope chain，所以會沿著outer reference往外層尋找此變數。
儘管greet()的exeuction context已經消失了，sayWelcome execution context仍然會有一條連到greet()的outer reference，連結到greet()的記憶體空間。
儘管函式已經完成，任何在其裡面建立的函式，當被呼叫的時後仍然會有outer reference連結到原本的函式記憶體空間。再多想想一次。
 greet()完成，execution context消失，但其中的的記憶體空間並沒消失。 Javascript Engine透過此記憶體空間確保其中的函式仍然有scope chain連結著，儘管此函式已不存在於execution stack中。  這樣的連結，通常會這樣說明，這個execution context已經封閉了，變數不管怎樣仍然會有reference，即使execution context已經消失。
上述的現象，這樣一個封閉的現象，execution context不存在仍然可以access到其中變數的況，我們就稱為closure。
Closure Again 我們一樣先看範例，想一想Output是什麼呢。
我們有一個function裡面建了一個空陣列，並有一個for loop將新建立的function放入陣列的內容，最後回傳陣列，你的答案可能會是 0,1,2，但實際上呢?
各位觀眾，3個3，同花打不打得過Full House?驚訝的程度大概就跟獨眼龍被翻盤的結果一樣，怎麼會這樣呢，為什麼3個都是3，或許你已經知道了，不知道的我們就一步一步來探究吧。
我們依然從execution stack來一探究竟。
 建立好global execution context，裡面包含build函式以及變數getArr。  第17行呼叫到了build()並assign給getArr，創立了build()execution context，執行內容並回傳arr。 注意到，迴圈裡，我們並 沒有呼叫 新建的函式，而單純只是新建函式塞到陣列，最後 i = 3 跳出迴圈，回傳陣列  回到global execution，build execution pop out，但昨天我們講到，記憶體空間並沒有跟著消失。  接著呼叫三個陣列裡的函式，所以當找不到i時，跟著scope chain開始尋找，最後找到3。   由上面可知，三個陣列裡的函式，三個函式都是再build()裡面被建立，都會找到沿著同樣的scope chain找到 i = 3，這也是為什麼會有3個3，明白了嗎~</description>
    </item>
    
    <item>
      <title>Asynchronous</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day18_asynchronous/</link>
      <pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day18_asynchronous/</guid>
      <description>Asynchronous 眾所皆知Javascript是synchronicity的，也就是同一個時間只能執行一件事情，但我們常常會聽到Asynchronous callbacks，這又是什麼呢?今天我們就來介紹這個主題吧。
What&amp;rsquo;s asynchronous 聰明的你不難猜出，簡易而言，asynchronous代表的是在一段時間內，不只執行一件事情，也就是當我們開始執行一段程式碼時，另一段程式碼也同是在運作了。
但我們知道，Javascript是synchronous的，它一次時間只執行一段code,然而我們知道Javascript有事件監聽例如點擊事件，或者是送要求然後將資料傳回的動作，當這些事件完成時會有一個callback function。
奇妙的事情發生了，Javascript是如何處理這些asynchronous的事件呢?
Javascript Engine 這時我們要回來探討Javascript Engine本身，它不只是一個單一的個體，它同時與其他元素互動，好比Browser，會有其他engines並執行code。
好比有一個Rendering Engine負責印出web page畫面、會有HTTP Request處理資料要求，而Javascript Engine與這些元素會有一個鉤子連結再一起，當程式碼有更新時，可以與其他引擎做溝通。
當程式碼執行時，這些Engines就有可能是asynchronous的，也就是這三個Engines在browser內可能是同步執行的，但只有Javascript Egine內部自己是synchronous。
我們之前已經知道Javascript有Execution stack ，當函式呼叫時會一層一層推疊，最上層優先執行，執行完後離開Stack。而Javascript Engine還有另一個 event queue 。
event queue event queue主要是存放事件、事件的通知，所以當今天browser有一個事件發生時，在Javascript Engine內我們需要知事件要發生了，這時就會把準備發生的事件堆到event queue裡面，讓我們可以對事件作監聽並準備做相對應的動作，而當Execution Stack清空後，Javascript才會去看event queue是否有需要處理的事件。
Sample 舉例來說，今天我們有函式對點擊事件作回應，或者有當函式執行時，又有另一個事件發生，例如送要求要資料，實際上整個流程怎麼跑呢?
當今天exeuction stack整個執行完畢清空時，接著Javascript會回來看Event queue，如果queue裡有事件在等待，若有的話，接著看這個事件是否有一個函式去處理事件發生的狀況，所以就範例而言，Javascript看到了點擊事件，並有一個clickHandler()函式處理。
Javascript知道有函式處理點擊事件後，此事件就會被移出queue，而下一步因為execution stack尚未被清空，所以Evet queue不會進執行流程，直到stack被清空為止，所以Javascript實際上並不是真的asynchronous，而是Broswer asynchronously的將事件存放進event queue裡面，Javascript egine仍然是一行一行執行code。
Sample again 接著我們用一個程式範例來看看。
這個範例中，我們有click event並有一個handler專門負責此事件，有一個需要執行三秒的function，以及一個當整個execution完成時提示訊息。Output的結果依序是 finish function、finish execution、click event。經過上面的sample應該不難推敲出這個結果，但我們還是實際上在重頭跑一次流程。
 建立好execution stack，並偵測到browser有點擊事件。  execution stack清空。查看event queue。  event queue有點擊事件，建立相對應的函式execution context。  點擊事件已有函式做處理，移出Event queue   以上就是整個流程，相信大家也能自己推導出來，強烈推薦大家自己重頭在想一次啊!</description>
    </item>
    
    <item>
      <title>Scope</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day16-scope/</link>
      <pubDate>Mon, 01 Jan 2018 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day16-scope/</guid>
      <description>Scope Scope是Javascript很重要的一個也非常需要花時間去消化的觀念，在一開始我們有講到，Javascript是一個很注重Lexical Environment的，而Scope正是其重要的原因，礙於Scope的觀念有點龐大，我們會用兩天的篇幅來介紹，而今天主要注重在以下。
 Variable Environment解釋 Sample推演 Scope chain  Variable Environment 這是我們第一次見到這個名詞，其中代表的意義為，變數在哪裡存活以及變數與變數在記憶體中的關聯性，看起來有點繞舌，我們可以簡化一下。
當今天提到Variable Environment，你就想著，變數到底在哪裡。
Sample推演 今天我們有function a、function b、變數 myVar，在往下滾動前，大家可以試著自己推導一下這段Code的流程。
  Step1 - 建立Global Execution Context，建立好變數及函式的記憶體空間，之後開始執行Code，讀取到myVar = 1，讀取到函式b的呼叫，進入Step2。   Step2 - 當讀取到b()，創立b( ) Execution Context，讀取到myVar = 2;再來讀取到函式a()的呼叫，進Step3
   Step3 - myVar = undefined.   以上就為整個流程，而其中我們注意到，每個Execution Context的橘色框框，代表著myVar變數，也就是vaiable environment，並與我們的主題Scope有關係，也就是我們何時能看見這些變數。
上圖我們看到每個變數都是被定義在各別的Execution Context，因為這些變數被包含在函式裡，每次函式被呼叫便有自己的Execution Context。
所以即便myVar，被宣告了三次，事實上它們三個是不一樣的個體，是各自單一的存在，並不會接觸到其他與自己相同名稱的變數。如以下。
每個myMvar，存在於各自的Execution Context中。
第二個Sample 接下來我們稍微將剛剛的範例修改一下如下圖，乍看之下是差不多的程式碼，真的是差不多，只有函式a的內容有變換，猜猜結果是什麼?
答案是1，你猜對了嗎? 50%的機率錯了也不用灰心，那猜2的人一定會問為什麼，猜中1的人也未必理解，沒關係，跟著我一起走一遍。
這次我們快轉三個步驟，可以得到下面的流程。
在函式a()我們這次為空的，並沒有宣告自己的myVar，當今天我們要取變數做行為時，Javascript不只看了此變數的execution context 的 variable environment，而同時也會看到它的外層 execution context。</description>
    </item>
    
    <item>
      <title>Hoisting</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day15_hoisting/</link>
      <pubDate>Sun, 31 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day15_hoisting/</guid>
      <description>Hoisting JS內有一個機制稱為Hoisting，那什麼是Hoisting呢?看看以下的程式碼。
在其他程式語言中，通常會先定義變數好才去做使用，尚未定義的變數去使用的話通常會有Error產生。
然而，Javascript內提供了一個機制叫做Hoisting，Javascript Engine把變數以及函式宣告的部分提移到程式的最上層，透過這個機制，就算變數使用在宣告前使用，不會有Error，所以實際上透過編譯後的程式碼比較像以下的範例。
今天就來講解Hoisting這個機制吧 !
Creation Phase 先前我們提到，程式執行時，會有Execution context，而其實Execution context是透過兩個階段創建出來的，第一階段稱為creation phase，第二階段為Execution Phase。
Creation Phase，我們知道初始一定會有global exection Context，也就是 Global Object &amp;amp; this	已經建立在記憶體中。
而當 Syntax Parser逐步閱讀我們的code並開始編譯時，它會先記住我們宣告變數以及函式的位置，因此Parser同時在Creation Phase中建立了記憶體位置準備存放這些變數以及函式，這個階段就稱為Hoisting。
Hoisting的解釋 所以實際上，我們並不是真的把code宣告的部分移到最上層，而是在程式真正開始逐行執行前，Javascript已經預先把所有在Code裡面的變數及函式的記憶體準備好，所以這些變數以及函式已經存在於記憶體中了，因此，在程式開始逐行執行的時候，就可以從記憶體抓取到這些變數及函式。
而注意到變數又跟函式的Hoisting有些差別，在建立記憶體給變數時，它並不知道實際的value是什麼，直到程式執行到的時候才會知道value，取而代之的是，它預先放了一個替代方案，undefined。如剛剛的範例。
總結 Hoisting的存在並不是要我們太過依賴於它，所以還是盡量避免在宣告前先使用的寫法，這很容易會困住自己的邏輯，而實際上我們真正探討的是為什麼Javasript能讓宣告前先使用的現象，而不是為了讓大家依賴這種寫法。
再來是我們知道了一件事情，我們寫的Code並不是就直接被執行，而是Javascript讀取了Code，並做決定。第一階段是替我們的code創立一個execution context，決定程式碼如何執行，並在執行前，替變數及函式建立好記憶體空間。
參考來源   eloquentjavascript  Udemy Course - JavaScript: Understanding the Weird Parts
  </description>
    </item>
    
    <item>
      <title>Higher-order Function</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day13_higher-order/</link>
      <pubDate>Sat, 30 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day13_higher-order/</guid>
      <description>Higher-order Function Function在Javascript是它馬重要的傢伙，記住它一個特別的特性，在JS裡，Function也可以是value，Assign到變數中，相同道理，function也可以被當作function的參數，聽起來有點弔詭，但其實我們在介紹陣列的方法中已經有看到這種用法。
一個function如果接受function為參數，或者，function 回傳的值是一個function，則稱之為Higher-order Functions。見範例。
 之前介紹的filter就是一個higher-order function 接受一個function (如果Area === Taipei)為參數。  好處是什麼 ? 試著想想，如果剛剛的範例不用filter來寫的話該如何做?
以下我們分成來比較，共同動作為，檢視每個元素，過濾符合條件的元素。
 在filter的使用下，我們只需要決定過濾內的函式如何執行。 手動的情況下，我們需要自建一個Array存放，並手寫一個for迴圈，並在條件式裡，撰寫儲存新Array的方式。  相比之下，哪一個方式比較繁瑣呢?答案應該很清楚。
透過Higher-order function，我們可以將簡單的函式，如上面條件判斷式的簡單函式當作參數，一步一步串成規模更大的程式，這樣的設計方式，不僅讓程式碼乾淨俐落，也不容易產生Bug，更ㄅㄧㄤˋ的是可以重複使用阿 !
 簡潔程式碼，不容易出錯。 函式可以再重複使用。 可以將大程式切割成簡單函式來組織。  Function Programming VS OOP 上面我們提到了Function Programming(FP)，其實還有另外一種概念就是Object-oriented Programming(OOP)，我們就來稍微介紹一下兩者的設計概念以及比較。
OOP 主要用Objects來達成程式目的，每個物件中有各自的屬性及方法，而有些物件是有共有特性的，透過這些物件互相的作用，每個物件都可以處理其相對應的動作並且將處理好的內容再傳達給其他物件。
而OOP最核心的概念就是 - 封裝、繼承、多型。
 封裝 - 可以讓別人使用，但別人不知道實際的細節 繼承 - 保有原物建的特性並做擴充。 多型 - 物件可以針具收到的任務而有不同的操作，只須注意物件是有否共同型別。  而PTT中有一篇強大的範例完整演繹了OOP的概念 如下
 面試官: 什麼是OOP?
  封裝 面試者: 我是個封裝良好的軟體工程師，您只要將任務交待給我，我就會把程式寫好，您可以不用耗費心力在細節中，可以去專心在您的核心 業務。
  繼承 我已經有在A公司當過N年軟體工程師的經驗，我以前的經驗可以繼承，您不用花時間心力成本教我訓練我，而且我會根據貴公司 的狀況調整我的工作方式。</description>
    </item>
    
    <item>
      <title>Deep into Functions </title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day12_deepintofunction/</link>
      <pubDate>Fri, 29 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day12_deepintofunction/</guid>
      <description>##Deep Into Functions 昨天的文章我們介紹了一些Functions的基本觀念，但Functions的細節卻遠超乎我們的想像，因此，今天我們就更深入地來探討Function的概念， 一起征服這隻大怪物吧，今天主要的介紹會有 - Call stack、Recursion、 Constructors、 IIFE 。
##Call Stack
我們知道了函式的概念，也知道了函式怎麼被呼叫使用，但函式實際上運行的樣子，以及背後的流程原理是什麼我們卻不清楚，現在就讓我們進一步看一看運作的原理，了解之後才更能避免錯誤的發生。
###函式運作的流程
首先我們有個範例。
實際上程式碼的運作是這樣的 -
 Global Execution Context被建立，同時會建立好 this、global object(window) 。 function sister &amp;amp; brother 因為hoisting的機制，會被建立在記憶體中，接著才開始逐行執行。  逐行執行後，看到了sister()這個函式呼叫，這時候，會建立sister的 execution context，並被堆疊到 execution stack中，最上層的 execution context會是執行中的。  進入sister函式，又讀取到呼叫 brother()這個函式，同上步驟，brother()的execution context被建立並堆疊到最上層開始執行。  5. 接著brother中讀到console.log()一樣被堆疊上去開始執行。 6. console.log()執行完後，被抽離出stack，進而brother()執行完抽離，再來是sister()執行完抽離，最後回到global execution context繼續逐行往下看。
####以上就是整個運作的流程，而存取這些 execution context的地方就叫做call stack。
##Recursion
接著介紹Recursion，所謂的Recursion指的就是函式呼叫函式本身，只要不超過stack的上限都是可以接受的，以下的範例就是一個Recursion。
以上透過函式呼叫函式自己的就是Recursion，但有一點要特別注意，用膝蓋想也知道，這樣一直呼叫函式的效能肯定會差的多了，雖然話是這樣說的沒錯，但你可以清楚發現，通常Recursion的版本會相對Loop版本的解法來的比較容易明白，兩者沒有一定的好壞。
Recursion擁有比較好的可讀性，但犧牲了效能，而Loop的方式擁有較好的效能，但在較複雜的結構會顯得艱澀迂迴，端看大家如何在兩者去做一個平衡。
但有一個很通用的規則大家可以考慮，當今天除非效能差得太明顯，否則建議是以可讀性高的寫法為優先，畢竟大程式不會是自己一個人全部負責，擁有好的可讀性對團隊來說是更好的選擇，當然如果效能真的差得太明顯，再去找出哪一個部分占用了最多時間，再用高效率低可讀性的方法取代掉就好了啊 !
##Constructors
Function在Javascript中也可以被當成Constructor使用，這樣的函示我們會稱為構造函式，以下為範例。
function User(name, friends) { this.name = name; this.friends = friends; this.</description>
    </item>
    
    <item>
      <title>Functions Basic</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day11_function/</link>
      <pubDate>Thu, 28 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day11_function/</guid>
      <description>##Functions
在Javascript裡，Functions佔了一個非常重要的角色，是最核心的部分，也是最容易造成誤解以及混淆的Part，今天吃完早餐後就來分享Function 函式吧。
##Functions Basic
function在Javascript可以說是最最最最重要而且最最最核心的觀念，透徹了解function的觀念，我們可以利用javascript做到一些其他程式語言所不能做到的事情，這個核心重點就是 - first class functions。
在Javascript中，function是 物件 ，first class function意思是指，它可以像其他types一樣被assgin到變數裡面，被當作參數使用，這也是Javascript強大的地方。
由於function是物件，所以function也可以包含其它properties &amp;amp; methods，可以連結object、function、primitive。而其中有兩個特別的property - Name &amp;amp; Code。
 name - 是指函數的名稱，不一定要有，可以是匿名函式。 code - 函式內我們所寫的code。  感覺上我們好像是自己寫了一個function的code，但其實我們只是將code新增到一個稱為CODE的property裡面。特別的部分在於，這個Code property是可以被呼叫的，也就是，可以執行code property裡面的code。
這是非常一個重要的觀念，我們得時刻記在心裡，function is object，其中的code只是這個object的一個property。
所以我們也可以做到下面這個看起來可能很奇妙的行為
function greet() { console.log(&#39;hi&#39;); } greet.language = &#39;English&#39;; console.log(greet.language); // &#39;English&#39;; 看起來或許很怪，但在Javascript這就是一個合理的事情。
回頭來看實際上這個function的架構。
它是一個object，有properties，code是被存在property的，記住它，絕對不要忘。
當用typeof 去檢查function時會回傳 &amp;lsquo;function&amp;rsquo;	，就算如此也要記住它是object。
typeof greet; // function ##Function的宣告方式
在知道函式的宣告前，我們得先知道兩個觀念 - function statement &amp;amp; function expression。最簡單的區別在於是否主動回傳一個value。
function expression 如範例，我們將函式存到變數裡，整個匿名function就是一個value。</description>
    </item>
    
    <item>
      <title>Value-copy &amp; Reference-copy</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day07_value-reference/</link>
      <pubDate>Wed, 27 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day07_value-reference/</guid>
      <description>##Value-copy &amp;amp; Reference-copy
Javascript的兩大Type，之前我們提到主要分別是value的存取方式，在先前自己學習時，是沒有特別在意這部分的，因為只要結果是正確的，管他是怎樣去指定或傳遞值，但後來發現，常常Output出來的結果跟自己預料中的有落差，進而一步造成Bug，後來才明白原來就是值的存取方式影響甚大，所以今天，我們就針對這個超級重要，他馬的真的很重要的觀念，好好理解一波，一起來挖掘這個深奧的Part。
###Copied by Value
先前說過Primitive type的存取方式都是透過Value，這是什麼意思呢? 當今天有一個primitive type 存取到a變數，
var a = 1; 我們可以說a變數擁有一個記憶體位址，指到實際上primitive value 1 存在的位置。 var b = a; 當今天我們將a在存到b的話，由於a是存放primitive type的，實體上b的結構會是這樣。
b存了一個新的記憶體位置，這個位置指像了一個新的primitive value 1，而這個value是從a的value複製過來的。這樣的方式就稱為By value。
你可以想像成By Value的話就像是做一個從本體做一個複製人，範例中的copiedByValue，function 收到的變數是Primitive Type時，就會做出複製人，此時的arg就是複製人，再次Output copiedByValue的話依然會是原本的市北許效舜，就算這個複製人已經去韓國一趟變成金城武了，本體依然還是許效舜，因為複製人有自己的記憶體位置，而這個位置的value被換成金城武，這就是Copied by Value。
var copiedByValue = &amp;quot;市北許效舜&amp;quot;; function change(arg) { arg = &amp;quot;市北金城武&amp;quot;; console.log(arg); } change(copiedByValue); // &amp;quot;市北金城武&amp;quot; console.log(copiedByValue); //&amp;quot;市北許效舜&amp;quot; ###Copied by Reference
而如果是object types則是by reference，範例以下。
var a = { num : 1}; var b = a; 實體架構則是如圖中所示。</description>
    </item>
    
    <item>
      <title>Basic Operators</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day06_operators/</link>
      <pubDate>Tue, 26 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day06_operators/</guid>
      <description>Operators 介紹完了Javascript types，我們知道Javascript的組成大概是這樣，Variable -&amp;gt; Value -&amp;gt;Types，一個變數可以給予一個Value，這個Value同時決定此變數的Type。
更精確的說法我們可以稱為，執行動作的句子是一個Statement，statement裡面又包含了Expression，而Expression正是由variable或者Value，或者是一段由Variable和Value透過Operators結合起來的一段式子。
聽起來有點抽象，我們直接舉出例子來看。
 2 是一個 value expression。 b 是一個 variable expression。 b * 2 是一個數學式expression，透過operator * 結合。 a = b * 2 則是一個assign expression。 整段結合起來便是一個statement。  那前面我們知道了 value、variable、types，今天就來看看Operators吧 !
Operator在幹嘛? 一般來說，Operator是一個特殊的函式，與一般函式的寫法不同，通常，operators讀取兩個參數後回傳一個新的結果。
例如常見的 = * + - 諸如此類，所以他實際上的用途就是在variable 與 value上面做一些行為，好比 * 就是將value做一個乘法的動作， = 就是負責assign這個動作。
特別注意到Assignment Operators的執行是從右到左稱為 Right-associativeity 以下見範例。
這段結果 a &amp;amp; b 的 value都會是5，那實際上的動作是這樣的
 b 被assign成 5 a 透過b的value被assign成 5  所以是從右邊先開始的，這就是Right-associative。
Operator的優先順序 有了上面的觀念，你會觀察到，那不一樣的Operator從哪邊開始先處理呢，實際上是這樣的，就像梁山108條好漢長幼有序，如此多的Operator也是要照輩分來的。以下就是常見到的Operator順序。</description>
    </item>
    
    <item>
      <title>Object Types</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day05_objecttypes/</link>
      <pubDate>Mon, 25 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day05_objecttypes/</guid>
      <description>##Object Types
在介紹Types，我們提到主要分成兩種，一為基本的Primitive Types，另一則為Object Types，透過存取方式的不同做區別，那今天就來介紹一下Object Types，而在後面也會針對copied by value &amp;amp; copied by reference 作探討。
###Objects
基本上，Javascript除了Primitive Types以外都算是Object，那麼什麼是Object呢，你可以想像成蓋房子一樣，Primitive Types就像是一塊磚子，但能單靠一塊一塊磚子疊出來的房子不可能大到哪裡去，是吧 ?這時候我們是不是就需要鋼筋阿水泥阿混擬土阿，將各種元素包在一起的的結構去建造出更大結構的房子，Object就是這樣的一個存在，Object可以讓我們將多個Value包再一起，也可以Object包Object，藉此能做出一個更複雜的結構完成更複雜的事情。
看起來有點模糊，我們直接來個情境，假如有一個人叫小明，身高172cm，體重80公斤，每天早上都會吃蛋餅，那單靠Primitive Types你需要怎麼做呢?想到我就累了，我知道你不會想自己嘗試的，所以我已經準備好了。
你一定覺得這樣太沒效率了，連低能如我都知道這樣太誇張地真的，這時候來看看Object的厲害。
透過Object的方式我們只要一個變數宣告便可以儲存多項訊息，接下來我們就針對Object內的細節做更多介紹。
###Object的宣告
Object的宣告方式很簡單，只要將想要放在一起的訊息用	大擴號{}	包起來，便是一個Object，每一個Property對應的value用 冒號:	丟過去，不同的屬性值則用 逗號 ,	隔開，可以看上方圖片做對應。
###Property
在物件中，每一個value對應會有一個Property，例如剛剛範例中的 name、height、weight、routine	就是這個物件的Property。 而注意到routine這個property是存了一個function的，我們通常會稱為這樣的Property為object的method。
###Property 的存取
那怎麼透過物件去得到這些Property所對應的值呢，我們就會用 句號. 來得到，除此之外也可以透過 [] ，而後者主要是用於當Property有特殊符號如空白或者變數名稱不符合規則時使用。
dot的方式 中括號的方式 ###Property的新增與刪除
Object內的新增與移除非常之簡單方便，新增的部分只要透過 = 直接直球進去就得分，而刪除只要透過delete就可以解決。 ###查看Object的狀況
常常我們Object內塞了一大堆東西，想要check的時候看得頭昏腦脹，在此分享一個好用的方式，可以讓check的時候更方便，這時候我們歡迎偉大的 console.table(object) ，讓我們一次一目瞭然。
###查看Property是否存在
通常Property不存在的狀況下會是 Undefined	，但你知道程式百百種，當一個property被刻意設成undefined的狀況下，這樣就不能判斷property的存在與否，這時我們就得依靠 in、hasOwnProerty() 來判斷，根據我們的慣例，兩個做一樣的事情，一定會有細節上不一樣，他們也不例外。
 in 主要是連obj內的prototype 都會搜索過一次，至於什麼是prototype後面會在介紹，你可以先想成只要是obj都會擁有的東西，就像是只要是人都有腦，腦就是一個prototype。 hasOwnProperty() 則只會搜索當前這個obj。   參考來源  eloquentjavascript  </description>
    </item>
    
    <item>
      <title>Undefined &amp; Null</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day04_tricky/</link>
      <pubDate>Sun, 24 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day04_tricky/</guid>
      <description>##Tricky Undefined &amp;amp; Null
今天這一章我們就來看一下前面沒細談的Undefined &amp;amp; Null types ! 一般在其他程式語言Null是被當作一個空值的，而在Javascript也是，但Javascript中又有另一個Undefined的type，，當這兩個做比較的時候會有很神奇的事情發生。
上圖中，當兩者用 == 比較時，是True，原因是兩個都代表著此變數不帶值， 而 === ，是較嚴謹的比較方式，連Type都會納入考量，所以是false。 同樣都代表著空值兩者差異到底在哪，但要說Undefined為不帶值聽起來是挺怪的我們下面會再解釋。
而通常我們如果想要假設某變數為空值，我們會用null而不會主動塞給變數undefined。
除了相異處，兩者也有共通點，例如兩者的Boolean default都是false。
但聰明如你，一定會試著用typeof 一窺他們的秘密，此時你會發現一個天大的消息，相信你一定重複按了很多次，嚴重懷疑是不是自己打錯了或是語法出了問題。
為什麼type null 不是null？這得追溯到Javscript的歷史了，但我是印象派，只喜歡個大概，所以為什麼會這樣就請看官有興趣自行上網查閱。
至於為什麼到至今的版本中，仍然沒改善這個問題，這是由於，目前有太多程式的運作是依賴這個Bug的特性，因此倘若改的話可能會有更多Bug出現，所以就不要期待這個Bug被修好吧嘿嘿。
###Undefined &amp;amp; is not defined ? 字面上來看這兩個應該是相同道理的，但並不是的，這也是容易讓人疑惑的部分，首先Undefined是不會有Error的，而 is not defined是Error給出的訊息。
在Javascript我們看到undefined，事實上並不是真的代表字面上的意思，而是代表著一個 Special Value	，它代表的是變數還沒被設定一個正常值。
而今天如果我們賦予了a一個值。
上面兩個範例我們可以看到，第一個還沒給予正常值的話，大家還記得的話，在Creation phase會創立所有變數到記憶體裡面，並給予一個undefined為初始。
而上面的範例又跟接下來的狀況不太一樣，特別注意到，如果今天我們連變數都沒宣告的話。
燈愣 ! Error出現了，那是因為在Creation phase的時候它並沒在程式碼找到 var a，因此並沒有替a建立好記憶體空間存放，也就是說a根本不再記憶體內，所以當要在程式碼執行時找到a，就會回傳error，因此我強烈覺得Javascript應該把這個error訊息改成 a is not declared，才不容易造成混淆。
所以undefined並不是真的代表空值或不存在，而應該說是一個非常特別的值，它一樣佔有記憶體空間，實際上代表著這個 special value是被Javascript主動建立的。
知道了這個道理之後，千千萬萬要記得，千萬別做以下這個動作。
事實上這個動作是不會產生Error的，但我們最好讓 undefined這個特殊值永遠代表著一個意思，就是我們，寫程式的人，並沒有替此變數設定一個正常值，也就是說當我們看到undefined就可以知道，阿~這個變數沒有被我們設定到值，這對於debug是非常有幫助的。
想想你如果做了上圖的動作，今天看到undefined，你會無法確定這個undefined到底是我們設定的還是Javascript初始塞入的，所以永遠讓undefined代表著一個意思就好 - 我們只有宣告並沒有設定這個值。
參考來源  eloquentjavascript You don&amp;rsquo;t know JS  </description>
    </item>
    
    <item>
      <title>Javascript Basic Types</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day03_primitivetypes/</link>
      <pubDate>Fri, 22 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day03_primitivetypes/</guid>
      <description>##Javascript Basic Types
##Vaiables
Variables主要是用來 存放 數值的，可以想像成它是一個保險箱，用來存放錢錢的，當然錢錢不能亂放，保險箱也不能亂蓋，否則是會有 渲染 問題的，這在後面的章節提Scope時會再詳加敘述。
在Javascript中，特別注意到Javascript的 Variables 是沒有 Type 的，而是由Variable中的 Value 去決定一個變數的Type，後面會針對Type作介紹。
而宣告變數的方法如下。
###小叮嚀 在宣告變數中，仍然有幾項規矩得注意。
 變數宣告的第一個字母必須是英文、底線(_)、錢字號($)。  Case Sensitive - 大小寫的宣告是不會被視為相同的變數，特別注意到宣告變數的時候僅有 var 是被認定的，如果是Var、VAR、vAR等都無法宣告變數的，而在ES6還多了let &amp;amp; const。  變數名稱不可為Reserved Words &amp;amp; Key Words 保留字參考 沒有透過 var 宣告的變數會被Javascript認定為global scope，這點非常之可怖，千萬要記住。  Types 由前面的介紹，我們對Variable有了基本的了解，而上面提到的Varaible並不帶有Type，而是由	Value 來決定，Javascript總共包含了	7 種Types，而在Javascript中針對Value的存取方式又分為，Primitivess Types(5) &amp;amp; Objects Types(2)	，分別為 copied by value &amp;amp; copied by reference	。
Primitives Types 依序為
 Number string boolean undefined null  Objects Types 依序為</description>
    </item>
    
    <item>
      <title>Javascript Intro</title>
      <link>https://WenXuanLee.github.io/posts/ironman30/day02_intro/</link>
      <pubDate>Thu, 21 Dec 2017 00:00:00 +0000</pubDate>
      
      <guid>https://WenXuanLee.github.io/posts/ironman30/day02_intro/</guid>
      <description>##Javascript Introduction
身為一個前端工程師，對前端三本柱子大家一定不陌生，HTML、CSS、Javascript，在一個Page裡面，Javascript又扮演著什麼樣的角色呢?
若用一個英文文法來說的話，HTML就是扮演著Nonus、CSS則是Adj、Javascript則是扮演著Verb的角色，也就是說，Javascript便是控制元素如何與使用者互動的部分，三者合為一體則可以完成一個標準的句子，也就是我們的Web Page。
主要介紹為
 Synyax Parsers、Execution Contenxts、Lexical Environments Javascript的小故事  ##Javascript 你不知道的事
Syntax Parser 今天我們寫了一隻Javascript的程式，裡面有密密麻麻的程式碼，身為一個人開發的人，理所當然地你會知道Code代表的意思是什麼，但對電腦而言呢？電腦是不明白我們看得Code，而Syntax Parser就登場囉，你可以想像成，Syntax Parser就像是一個翻譯，負責將我們的Javascript Code 翻譯給電腦讀，進而執行程式。
所以當我們今天的Javascript Code執行時，會先經過Syntax Parser一字一句讀取我們的程式，並判斷這個語法是否有效，將有效的語法翻譯成電腦可以明白的方式。
###Lexical Environment
Lexical的原意為，與字詞或語法相關的。Lexical Environment在Javascript代表的是，今天我們Code寫在哪個 位置	，是非常重要的。
上面我們看到有一個變數，在函式裡面，這變數在字詞上來說就是坐落於、存在於這個函式，這隻函式{ &amp;hellip; } 就是一個Lexical Environment。
就如我們上面講的，我們寫的Code是會經過Syntax Parser翻譯的，而翻譯的過程它是對於這些字詞存在的位置很在意的，寫的位置是會影響存放於電腦記憶體中的位置，以及如何去與其他變數、函式、元素互動的。
所以當我們提到Lexical Environment中，便是在討論code是被寫在哪個段落位置以及被什麼東西涵蓋住。一隻程式
###Execution Context
一隻程式函式這麼多，到底要怎麼知道目前是哪段Code正在執行阿，搞得我好亂R，這時候我們就歡迎偉大的Execution Context，拯救我們的世界。
Execution Context就像是一張包裝紙，幫助管理哪段Code正在被執行。如同我們上面提到的，一隻程式會有許多個Lexical Environment，那哪一個先執行便是透過Execution Contexts管理。
而最基本的Execution Context就是 Global Execution Context，每隻Javascript程式一開始一定會有的傢伙，而這傢伙在一開始便替我們做兩件事，創造 Global Object &amp;amp; This。
Global Object - 在Code裡面不管哪個元素不管在哪個段落都可以Access到的物件。 this - 之後會有篇幅說明
###ECMAScript Javascript是一個普遍的稱呼，嚴格上來說，Javascript是符合	ECMAScript標準 的一個實作，而ECMAScript標準是不止一個版本的，隨著時代演進，尤其在近年前端的大量改革下，ECMAScript近幾年也開始頻繁性的改動。
而目前ECMAScript主要常見的有以下三種
 ES5 = ECMAScript 5 ES6 = ECMAScript 6 ES7 = ECMAScript 7  基本上除了ES5的標準目前是被主流Browser接受外，目前ES6與ES7的一些新語法及規範還尚未被Browser完全採納，但，身處一個不斷進化的世代，還是建議以未來的標準去撰寫。</description>
    </item>
    
  </channel>
</rss>
